<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小灰灰的乱世奇谈</title>
    <link>https://buyunhui.github.io/</link>
    <description>Recent content on 小灰灰的乱世奇谈</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>suiyelian(卜云辉)</copyright>
    <lastBuildDate>Mon, 23 Apr 2018 21:41:52 +0800</lastBuildDate>
    
        <atom:link href="https://buyunhui.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://buyunhui.github.io/about/</link>
      <pubDate>Mon, 23 Apr 2018 21:41:52 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/suiyelian/&#34;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;suiyelian@outlook.com&#34;&gt;outlook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;联系方式：120881997@qq.com&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Exceptional C&#43;&#43;读书笔记一</title>
      <link>https://buyunhui.github.io/post/c&#43;&#43;%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/c&#43;&#43;%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
      
        <description>

&lt;h2 id=&#34;c-c-读书系列-effectivec-中文版&#34;&gt;c/c++读书系列(EffectiveC++中文版)&lt;/h2&gt;

&lt;h3 id=&#34;1-取值迭代器时-务必确保迭代器有效&#34;&gt;1.取值迭代器时，务必确保迭代器有效&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;有效的数值：避免*iter.end(),直接复位了。。。&lt;/li&gt;
&lt;li&gt;有效的寿命：迭代器使用时还有效么？循坏遍历时特别注意，插入等一些操作会使迭代器失效&lt;/li&gt;
&lt;li&gt;有效的范围：迭代器范围，步进等操作不要出现无效范围&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2-明白string类并不是一个真正意义上的类型&#34;&gt;2.明白string类并不是一个真正意义上的类型&lt;/h3&gt;

&lt;h4 id=&#34;编写一个忽略大小写的string类-其他方面与string类型一样&#34;&gt;编写一个忽略大小写的string类，其他方面与string类型一样&lt;/h4&gt;

&lt;p&gt;先上源代码在解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;

struct ignoreCaseString :public  char_traits&amp;lt;char&amp;gt;
{
    static bool eq(char c1, char c2)
    {
        return toupper(c1) == toupper(c2);
    }

    static bool ne(char c1, char c2)
    {
        return toupper(c1) == toupper(c2);
    }

    static bool lt(char c1, char c2)
    {
        return toupper(c1) &amp;lt; toupper(c2);
    }
    static bool gt(char c1, char c2)
    {
        return toupper(c1) &amp;gt; toupper(c2);
    }

    static int compare(const char* s1, const char *s2, size_t n)
    {
        /*
        功能：比较内存区域buf1和buf2的前count个字节但不区分字母的大小写
        说明：memicmp同memcmp的唯一区别是memicmp不区分大小写字母  
        当buf1&amp;lt;buf2时，返回值&amp;lt;0
        当buf1=buf2时，返回值=0
        当buf1&amp;gt;buf2时，返回值&amp;gt;0
        */
        return _memicmp(s1, s2, n);
    }

    static const char* find(const char * s, int n, char c)
    {
        while (n-- &amp;gt; 0 &amp;amp;&amp;amp; toupper(*s) != toupper(c))
        {
            ++s;
        }
        return s;
    }
};

typedef basic_string&amp;lt;char, ignoreCaseString&amp;gt; igString;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在C++，string簇类实际上均是别名,查看源码得&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using string = basic_string&amp;lt;char, char_traits&amp;lt;char&amp;gt;, allocator&amp;lt;char&amp;gt;&amp;gt;;
using wstring = basic_string&amp;lt;wchar_t, char_traits&amp;lt;wchar_t&amp;gt;, allocator&amp;lt;wchar_t&amp;gt;&amp;gt;;
using u16string = basic_string&amp;lt;char16_t, char_traits&amp;lt;char16_t&amp;gt;, allocator&amp;lt;char16_t&amp;gt;&amp;gt;;
using u32string = basic_string&amp;lt;char32_t, char_traits&amp;lt;char32_t&amp;gt;, allocator&amp;lt;char32_t&amp;gt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分配器部分不用我们去管理，编译器自己会为我们分配相应的内存，char_traits决定了string的比较等基本操作，其方法大致如下(c++14)
&lt;img src=&#34;C:UsersadminPicturesignore.png&#34; alt=&#34;ignore.png&#34; /&gt;
因此，只要我们重载了比较函数，就可以实现字符串的大小写忽略&lt;/p&gt;

&lt;h3 id=&#34;3-使用模板使代码复用性最高-产品代码模板是否可用-待商榷&#34;&gt;3.使用模板使代码复用性最高（产品代码模板是否可用，待商榷）&lt;/h3&gt;

&lt;h4 id=&#34;3-1-模板含义&#34;&gt;3.1 模板含义：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;模板是 C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模
式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。&lt;/li&gt;
&lt;li&gt;模板是一种对类型进行参数化的工具；&lt;/li&gt;
&lt;li&gt;通常有两种形式： 函数模板和类模板；&lt;/li&gt;
&lt;li&gt;函数模板针对仅参数类型不同的函数；&lt;/li&gt;
&lt;li&gt;类模板针对仅数据成员和成员函数类型不同的类。&lt;/li&gt;
&lt;li&gt;使用模板的目的就是能够让程序员编写与类型无关的代码。 比如编写了一个交换两个 整型 int 类型的 swap 函数，这个函数就只能实现 int 型，对 double，字符这些类型无法实 现，要实现这些类型的交换就要重新编写另一个 swap 函数。使用模板的目的就是要让这程. 序的实现与类型无关，比如一个 swap 模板函数，即可以实现 int 型，又可以实现 double 型 的交换。模板可以应用于函数和类。下面分别介绍。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围， 函数内进行，比如不能在 main 函数中声明或定义一个模板&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-2-语法格式&#34;&gt;3.2 语法格式&lt;/h4&gt;

&lt;p&gt;函数模板：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class 形参名， class 形参名， ......&amp;gt; 返回类型 函数名(参数列表)
    {
        函数体
    }
    template &amp;lt;class T&amp;gt; void swap(T&amp;amp; a, T&amp;amp; b){}
    类模板：
    template&amp;lt;class 形参名， class 形参名， …&amp;gt; class 类名
    { 
     ... 
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;class T&amp;gt; class A{public: T a; T b; T hy(T c, T &amp;amp;d);};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 template 和 class 是关键字， class 可以用 typename 关见字代替，在这里 typename和 class 没区别， &amp;lt;&amp;gt;括号中的参数叫模板形参，模板形参和函数形参很相像， 模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。 模板形参需要调用该模板函数时提供的模板实参来初始化模板形参，一旦编译器确定了实际的模板实参类型就称他实例化了函数模板的一个实例。比如 swap 的模板函数形式为&lt;/p&gt;

&lt;h4 id=&#34;3-3-模板的形参&#34;&gt;3.3 模板的形参&lt;/h4&gt;

&lt;p&gt;有三种类型的模板形参：类型形参，非类型形参和模板形参&lt;/p&gt;

&lt;h5 id=&#34;a-类型形参&#34;&gt;A 类型形参&lt;/h5&gt;

&lt;p&gt;类型模板形参： 类型形参由关见字 class 或 typename 后接说明符构成，如
template&lt;class T&gt; void h(T a){};其中 T 就是一个类型形参，类型形参的名字由用户自已确定。
模板形参表示的是一个未知的类型。模板类型形参可作为类型说明符用在模板中的任何地
方，与内置类型说明符或类类型说明符的使用方式完全相同，即可以用于指定返回类型，变
量声明等&lt;/p&gt;

&lt;h5 id=&#34;b-非类型形参&#34;&gt;B 非类型形参&lt;/h5&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非类型模板形参： 模板的非类型形参也就是内置类型形参，如 template&lt;classT, int a&gt; class B{};其中 int a 就是非类型的模板形参。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板的内部是常量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非类型模板的形参只能是整型，指针和引用，像 double， String, String **这 样的类型是不允许的。 但是 double &amp;amp;， double *， 对象的引用或指针是正确的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用非类型模板形参的实参必须是一个常量表达式，即他必须能在编译时计算出结果。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意： 任何局部对象，局部变量，局部对象的地址， 局部变量的地址都不是 一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;全局变量的地址或引用，全局对象的地址或引用 const 类型变量是常量表达 式，可以用作非类型模板形参的实参。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sizeof 表达式的结果是一个常量表达式，也能用作非类型模板形参的实参。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当模板的形参是整型时调用该模板时的实参必须是整型的，且在编译期间是常量，比如 template &lt;class T, int a&gt; class A{};如果有 int b，这时 A&lt;int, b&gt; m;将出错，因为 b不是常量，如果 const int b，这时 A&lt;int, b&gt; m;就是正确的，因为这时 b 是常量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非类型形参一般不应用于函数模板中，比如有函数模板 template&lt;class T, int a&gt; void h(T b){}，若使用 h(2)调用会出现无法为非类型形参 a 推演出参数的错误，对这种模板函数可以用显示模板实参来解决，如用 h&lt;int, 3&gt;(2)这样就把非类型形参 a 设置为整数 3。显示模板实参在后面介绍。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非类型模板形参的形参和实参间所允许的转换
a.  允许从数组到指针，从函数到指针的转换。如： template &lt;int *a&gt; class A{}; int b[1]; A&amp;lt;b&amp;gt; m;即数组到指针的转换
b. const 修饰符的转换。如： template&lt;const int *a&gt; class A{}; int b; A&amp;lt;&amp;amp;b&amp;gt; m; 即 从 int *到 const int *的转换。
c. 提升转换。如： template&lt;int a&gt; class A{}; const short b=2; A&amp;lt;b&amp;gt; m; 即从 short到 int 的提升转换
d. 整值转换。如： template&lt;unsigned int a&gt; class A{}; A&amp;lt;3&amp;gt; m; 即从 int 到unsigned int 的转换。
e.常规转换。&lt;/p&gt;

&lt;h4 id=&#34;3-4-类模板的默认模板类型形参&#34;&gt;3.4 类模板的默认模板类型形参&lt;/h4&gt;

&lt;p&gt;1、可以为类模板的类型形参提供默认值，但不能为函数模板的类型形参提供默认值。
函数模板和类模板都可以为模板的非类型形参提供默认值。
2、类模板的类型形参默认值形式为： template&lt;class T1, class T2=int&gt; class A{};为第二个
模板类型形参 T2 提供 int 型的默认值。
3、类模板类型形参默认值和函数的默认参数一样，如果有多个类型形参则从第一个形
参设定了默认值之后的所有模板形参都要设定默认值，比如 template&lt;class T1=int, class
T2&gt;class A{};就是错误的，因为 T1 给出了默认值，而 T2 没有设定。
4、在类模板的外部定义类中的成员时 template 后的形参表应省略默认的形参类型。比
如 template&lt;class T1, class T2=int&gt; class A{public: void h();}; 定义方法为 template&lt;class
T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}&lt;/p&gt;

&lt;h3 id=&#34;写一个具有最大通用性的容器&#34;&gt;写一个具有最大通用性的容器&lt;/h3&gt;

&lt;p&gt;写一个自适应长度的容器类,下面代码注释前，根据经验，写一个拷贝与复制构造函数，从已有的容器拷贝一份size大小的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T, size_t size&amp;gt;
class fixed_vector {
public:
    typedef T* iterator;
    typedef const T* const_iteraor;
    fixed_vector() {}
    template&amp;lt;typename 0, size_t osize&amp;gt;
    /*
    fixed_vector(const fixed_vector&amp;lt;0, size_t osize&amp;gt;&amp;amp;other)
    {
        copy(other.begin(), other.begin() + min(size, osize), begin());
    }
    template&amp;lt;typename 0, size_t osize&amp;gt;
    fixed_vector&amp;lt;T, size&amp;gt;&amp;amp;
    operator=(const fixed_vector&amp;lt;0, size_t osize&amp;gt;&amp;amp;other)
    {
        copy(other.begin(), other.begin() + min(size, osize), begin());
        return  *this;
    }*/
    iterator begin() { return v_; };
    iterator end() {return v_+ size};
    const_iterator begin()  const{ return v_; };
    const_iterator end() const{ return v_ + size };

private:
    T v_[size];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;拷贝与赋值构造函数操作只对类型完全相同的对象进行，如果是一个模板类，模板的参数也必须相同，所以上述代码只是一个虚有其表的构造函数与赋值函数，系统还是会为这个类生成默认的拷贝构造函数与拷贝赋值函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    fixed_vector&amp;lt;char, 4&amp;gt; v;
    fixed_vector&amp;lt;int, 4&amp;gt; w;
    fixed_vector&amp;lt;int, 4&amp;gt;w2(w); //W与w2不是相同类型对象
    fixed_vector&amp;lt;int, 4&amp;gt;w3(v); //W与w3是相同类型对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面实例可以得知，上述代码只是增加了拷贝构造与拷贝赋值的适应性，当然还可以继续添加其他入参的拷贝赋值与构造函数，以实现更多的复用性,下面提供另外的实现方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;Iter&amp;gt;
    fixed_vector(Iter begin, Iter end ) 
    {
        copy(begin ,begin+ min(size, end - begin), begin());
    } //拷贝构造

    template&amp;lt;Iter&amp;gt;
    fixed_vector&amp;lt;T, size&amp;gt;&amp;amp;
        assign(Iter begin, Iter end)
    {
        copy(begin, begin + min(size, end - begin), begin());
        return  *this;
    }//v.assign 调用assign追求效率更高，从其他地方赋值操作过来效率不是很好
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;临时对象优化-与尽量使用标准库函数&#34;&gt;临时对象优化 与尽量使用标准库函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;临时对象产生的三种主要类型：&lt;/strong&gt;
1. 以值的方式给函数传参 &amp;mdash;-》 尽量传引用（再尽量传const的引用）
2. 隐式类型转换          &amp;mdash; 》 尽量使用显示转换，自定义类时，可使用explicit对构造函数进行声明，可以禁止隐式转换
3.  函数返回一个对象时  返回引用（很危险，可不优化），返回值产生临时对象（如返回类型string，return &amp;ldquo;&amp;rdquo;; 将产生一个临时string对象返回，可以先对返回值声明）&lt;/p&gt;

&lt;h3 id=&#34;class-设计注意事项&#34;&gt;class 设计注意事项&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;构造函数尽量使用explict&lt;/li&gt;
&lt;li&gt;运算符重载务必遵循以下规则
&lt;img src=&#34;.1.png&#34; alt=&#34;1.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;定义了operate+ 就应该定义对应的operate+=&lt;/li&gt;
&lt;li&gt;总是在operate&amp;lt;&amp;lt; 与operate&amp;gt;&amp;gt;中返回引用&lt;/li&gt;
&lt;li&gt;前置++ 与后置++重载&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    A&amp;amp; operator++()  
    {  
        ++m_i;  
        return *this;  
    }  // 注意返回值类型
    // i++  
    const A operator++(int)  
    {  
        A tmp = *this;  
        ++(*this);    // Implemented by prefix increment  
        return A(tmp);  
    }  // 注意返回值类型
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>python decorate</title>
      <link>https://buyunhui.github.io/post/python-decorate/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/python-decorate/</guid>
      
        <description>

&lt;h2 id=&#34;python-装饰器&#34;&gt;python 装饰器&lt;/h2&gt;

&lt;p&gt;现在需要在函数运行前后打印一条日志, 但是又不希望或者没有权限修改函数内部的结构, 就可以用到装饰器(decorator):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def log(function):

    def wrapper(*args, **kwargs):

        print &#39;before function [%s()] run.&#39; % function.__name__

        rst = function(*args, **kwargs)

        print &#39;after function [%s()] run.&#39; % function.__name__

        return rst

    return wrapper 



@log

def func():

    print &#39;func() run.&#39;



output：

before function [func()] run.

func() run.

after function [func()] run.

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-函数装饰器&#34;&gt;1.函数装饰器&lt;/h3&gt;

&lt;h4 id=&#34;1-1-无参数装饰器&#34;&gt;1.1 无参数装饰器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def outer(some_func):

    def inner():

        print(&amp;quot;before some_func&amp;quot;)

        ret = some_func() # 1

        return ret + 1

    return inner



def foo():

    return 1

decorater = outer(foo)

print(decorater())



output:

before some_func

2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**使用@&lt;/p&gt;

&lt;p&gt;@outer等价 decorater = outer(foo) **&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
@outer

def foo1():

    return 1

print(foo1())



output:

before some_func

2

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-装饰函数有参数-args-和-kwargs&#34;&gt;1.2 装饰函数有参数（ args 和 *kwargs）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;*args 只在定义函数时用来表示位置参数将会保存在变量 args 中。Python 也允许指定一些变量，并捕获任何在 args 里的额外参数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;（*）符号也可以用在函数调用时，在这里它也有类似的意义。在调用函数时，以 * 开头的变量表示该变量内容需被取出用做位置参数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&amp;gt;&amp;gt;&amp;gt; def add(x, y):

...     return x + y

&amp;gt;&amp;gt;&amp;gt; lst = [1,2]

&amp;gt;&amp;gt;&amp;gt; add(lst[0], lst[1]) # 1

3

&amp;gt;&amp;gt;&amp;gt; add(*lst) # 2

3



&amp;gt;&amp;gt;&amp;gt; def foo(**kwargs):

...     print kwargs

&amp;gt;&amp;gt;&amp;gt; foo()

{}

&amp;gt;&amp;gt;&amp;gt; foo(x=1, y=2)

{&#39;y&#39;: 2, &#39;x&#39;: 1}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当定义一个函数时，使用 **kwargs 来表示所有未捕获的关键字参数将会被存储在字典 kwargs 中。此前 args 和 kwargs 都不是 Python 中语法的一部分，但在函数定义时使用这两个变量名是一种惯例。和 * 的使用一样，可以在函数调用和定义时使用 **。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&amp;gt;&amp;gt;&amp;gt; dct = {&#39;x&#39;: 1, &#39;y&#39;: 2}

&amp;gt;&amp;gt;&amp;gt; def bar(x, y):

...     return x + y

&amp;gt;&amp;gt;&amp;gt; bar(**dct)

3

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-3-装饰器本身有参数&#34;&gt;1.3 装饰器本身有参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def log(text=&#39;&#39;):

    def decorator(function):

        @functools.wraps(function)

        def wrapper(*args, **kwargs):

            print &#39;before function [%s()] run, text: [%s].&#39; % (function.__name__, text)

            rst = function(*args, **kwargs)

            print &#39;after function [%s()] run, text: [%s].&#39; % (function.__name__, text)

            return rst 

        return wrapper

    return decorator



@log(&#39;log text&#39;)

def func():

    print &#39;func() run.&#39;



output:

before function [func()] run.

func() run.

after function [func()] run.



def external_function(i, j):

    k = i - j

    def decorator(func):

        def wrapper(*arg):

            print(&#39;this func is %s&#39;%(func.__name__))

            print(k * func(*arg))

        return wrapper

    return decorator



@external_function(10,5)

def my_func(x,y):

    return x + y



if __name__ == &#39;__main__&#39;:

    my_func(10, 2)



this func is my_func

60

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-4-装饰器调用顺序&#34;&gt;1.4 装饰器调用顺序&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def dec1(func):

    print(&amp;quot;entry dec1&amp;quot;)

    def wapper(a, b):

        print(&amp;quot;enter dec1 wapper&amp;quot;)

        func(a,b)

    return wapper

    

def dec2(func):

    print(&amp;quot;entry dec2&amp;quot;)

    def wapper2(a, b):

        print(&amp;quot;enter dec2 wapper&amp;quot;)

        func(a,b)

    return wapper2



@dec1

@dec2

def Add(a, b):

    print(a + b)

    

Add(1, 2)



output:



entry dec2

entry dec1

enter dec1 wapper

enter dec2 wapper

3

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考上面例子，首先执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
@dec2

def Add(a, b):

    print(a + b)

    

返回

dec2函数的wapper2

接着执行

@dec1

wapper2

接着执行dec1的wapper函数，wapper2作为func参数传入最后执行

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-5装饰器会改变函数签名&#34;&gt;1.5装饰器会改变函数签名&lt;/h4&gt;

&lt;p&gt;使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
ef logged(func):

    def with_logging(*args, **kwargs):

        &amp;quot;with_logging&amp;quot;

        print(func.__name__ + &amp;quot; was called&amp;quot;)

        return func(*args, **kwargs)

    return with_logging



@logged

def f(x):

    &amp;quot;&amp;quot;&amp;quot;does some math&amp;quot;&amp;quot;&amp;quot;

    return x + x * x

if __name__ == &#39;__main__&#39;:

    f(2)

    print(f.__name__) # prints &#39;with_logging&#39;)

    print(f.__doc__ )# prints with_logging)

 

@logged

def f(x)



等价于 f = logged(f)

锁函数f被with_logging所代替了，相应的doc,__name__等属性也就被代替了



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-类装饰器&#34;&gt;2.类装饰器&lt;/h3&gt;

&lt;p&gt;相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器还可以依靠类内部的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。&lt;/p&gt;

&lt;h4 id=&#34;2-1-不带参数的类装饰器&#34;&gt;2.1 不带参数的类装饰器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Foo(object):

    def __init__(self, func):

        self._func = func

        

    def __call__(self):

        print(&amp;quot;class decorater runing&amp;quot;)

        self._func()

        print(&amp;quot;class decorater runing&amp;quot;)       

@Foo

def bar():

    print(&amp;quot;bar&amp;quot;)

    

output:

class decorater runing

bar

class decorater runing

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;@Foo

def bar(): 等价于 bar = Foo(bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-带参数的类装饰器&#34;&gt;2.2 带参数的类装饰器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class tracer:  



    def __init__(self, *args):  

        self.calls = 0

        self.args = args



    def __call__(self, func):

        self.func = func

        def realfunc(*args):

              self.calls += 1

              print(&#39;call %s to %s&#39; %(self.calls, self.func.__name__))

              self.func(*args)

        return realfunc



@tracer(&amp;quot;xxxx&amp;quot;)

def spam(a, b, c):   

    print(a + b + c)  



if __name__ == &#39;__main__&#39;:

    spam(1,2,3)

    

output:

call 1 to spam

6

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-函数装饰器修饰类方法&#34;&gt;3. 函数装饰器修饰类方法&lt;/h3&gt;

&lt;p&gt;有一个类Test, 它的结构如下:现在我需要捕获一个异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Test(object):

    def __init__(self):

        pass



    def revive(self):

        print(&#39;revive from exception.&#39;)

        # do something to restore



    def read_value(self):

        print(&#39;here I will do something.&#39;)

        # do something.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用装饰器来解决这个问题，装饰器函数应该写在类里面还是类外面呢？答案是，写在类外面。那么既然写在类外面，如何调用这个类的其他方法呢？&lt;/p&gt;

&lt;p&gt;首先写出一个最常见的处理异常的装饰器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def catch_exception(origin_func):

    def wrapper(*args, **kwargs):

        try:

            u = origin_func(*args, **kwargs)

            return u

        except Exception:

            return &#39;an Exception raised.&#39;

    return wrapper





class Test(object):

    def __init__(self):

        pass



    def revive(self):

        print(&#39;revive from exception.&#39;)

        # do something to restore



    @catch_exception

    def read_value(self):

        print(&#39;here I will do something.&#39;)

        # do something.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法，确实可以捕获到origin_func()的异常，但是如果在发生异常的时候，需要调用类里面的另一个方法来处理异常，这又应该怎么办？答案是给wrapper增加一个参数：self.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def catch_exception(origin_func):

    def wrapper(self, *args, **kwargs):

        try:

            u = origin_func(self, *args, **kwargs)

            return u

        except Exception:

            self.revive() #不用顾虑，直接调用原来的类的方法

            return &#39;an Exception raised.&#39;

    return wrapper





class Test(object):

    def __init__(self):

        pass



    def revive(self):

        print(&#39;revive from exception.&#39;)

        # do something to restore



    @catch_exception

    def read_value(self):

        print(&#39;here I will do something.&#39;)

        sada # 人造异常

        # do something.





if __name__ == &#39;__main__&#39;:

    test = Test()

    test.read_value()

    

output:

here I will do something.

revive from exception.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>python functools详解</title>
      <link>https://buyunhui.github.io/post/python-functools_/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/python-functools_/</guid>
      
        <description>

&lt;h2 id=&#34;center-functools-高阶函数&#34;&gt;&lt;center&gt;functools — 高阶函数&lt;/h2&gt;

&lt;h3 id=&#34;functools-cmp-to-key-func&#34;&gt;functools.cmp_to_key(func)&lt;/h3&gt;

&lt;p&gt;它是一个key函数，可提供给sorted(), min(), max(), heapq.nlargest(), heapq.nsmallest(), itertools.groupby().等函数使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;eg:sorted(iterable, key=cmp_to_key(locale.strcoll)) # locale-aware sort order
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;functools-lru-cache-maxsize-128-typed-false&#34;&gt;@functools.lru_cache(maxsize=128, typed=False)&lt;/h3&gt;

&lt;p&gt;装饰器用一个有记忆的调用包装一个函数，它可以保存最近maxsize次调用。当使用同样的参数定期调用费时或I/O绑定的函数时，它可以节省时间。&lt;/p&gt;

&lt;p&gt;因为使用字典缓存结果，所以函数的位置和关键字参数必须是hashable。&lt;/p&gt;

&lt;p&gt;如果maxsize设置为None，则禁用LRU功能，并且缓存可以无限增长。当maxsize设置为&lt;img src=&#34;https://latex.codecogs.com/gif.latex?2^n&#34;/&gt;时，性能最佳。&lt;/p&gt;

&lt;p&gt;如果typed设置为真，则不同类型的函数参数会分别缓存。例如，f(3)和f(3.0)将视为不同结果的不同调用。&lt;/p&gt;

&lt;p&gt;为了帮助测量缓存的有效性并调整maxsize参数，包装函数使用cache_info()函数返回一个命名元组，包括hits，misses，maxsize和currsize。在多线程环境中，hits和misses是近似值。&lt;/p&gt;

&lt;p&gt;装饰器还提供了cache_clear()函数用于清除缓存，或者让缓存失效。&lt;/p&gt;

&lt;p&gt;原始的底层函数通过wrapped属性访问。这对于内省，绕过缓存，或者重新装饰函数很有用。&lt;/p&gt;

&lt;p&gt;当最近调用是即将调用的最佳调用因子时（例如，新闻服务器上的最受欢迎文章常常每天改变），LRU（least recently used）缓存效果最好。缓存的大小限制确保缓存不会在长时间运行的进程（如web服务器）上不受限制的增长&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@lru_cache(maxsize=None)
def fib(n):
    if n &amp;lt; 2:
        return n
    return fib(n-1) + fib(n-2)
  
&amp;gt;&amp;gt;&amp;gt; [fib(n) for n in range(16)]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
  
&amp;gt;&amp;gt;&amp;gt; fib.cache_info()
CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)
  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;functools-total-ordering&#34;&gt;@functools.total_ordering&lt;/h3&gt;

&lt;p&gt;给定的一个类定义了一个或多个富比较方法，该类装饰器提供剩下的。这简化了指定所有富比较操作的工作量。&lt;/p&gt;

&lt;p&gt;类必须定义&lt;strong&gt;lt&lt;/strong&gt;()，&lt;strong&gt;le&lt;/strong&gt;()，&lt;strong&gt;gt&lt;/strong&gt;()或&lt;strong&gt;ge&lt;/strong&gt;()的其中一个。此外，类应该提供一个&lt;strong&gt;eq&lt;/strong&gt;()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@total_ordering
class Student:
    def _is_valid_operand(self, other):
        return (hasattr(other, &#39;lastname&#39;) and
                hasattr(other, &#39;firstname&#39;))
    def __eq__(self, other):
        if not self._is_valid_operand(other):
            return NotImplemented
        return ((self.lastname.lower(), self.firstname.lower()) ==
                (other.lastname.lowher(), other.firstname.lower()))
    def __lt__(self, other):
        if not self._is_valid_operand(other):
            return NotImplemented
        return ((self.lastname.lower(), self.firstname.lower()) &amp;lt;
                (other.lastname.lower(), other.firstname.lower()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：虽然该装饰器能很容易的创建行为良好的完全有序类型，但会导致衍生出的比较函数执行的更慢，以及更复杂的堆栈跟踪。如果性能基准测试表明这是程序的瓶颈，则实现所有六个富比较函数可能会是提高速度的方式&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;functools-partial-func-args-keywords&#34;&gt;**functools.partial(func, *args, &lt;strong&gt;keywords)&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;返回一个新的partial对象，该对象被调用时，类似使用位置参数args和关键字参数keywords调用func。如果调用时提供了更多参数，它们会被添加到args。如果提供了额外的关键字参数，它们会扩展和覆盖keywords。大致等价于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*args, *fargs, **newkeywords)
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
  
partial()用于冻结函数的某些参数和/或关键字参数，生成一个简化的签名对象。例如，用于创建一个类似int()函数的可调用对象，其中base参数默认为2：
eg:
&amp;gt;&amp;gt;&amp;gt; from functools import partial
&amp;gt;&amp;gt;&amp;gt; basetwo = partial(int, base=2)
&amp;gt;&amp;gt;&amp;gt; basetwo.__doc__ = &#39;Convert base 2 string to an int.&#39;
&amp;gt;&amp;gt;&amp;gt; basetwo(&#39;10010&#39;)
18
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;class-functools-partialmethod-func-args-keywords&#34;&gt;class functools.partialmethod(func, *args, **keywords)&lt;/h3&gt;

&lt;p&gt;返回一个行为类似partial的新partialmethod描述符，除了它是用于方法定义，而不是直接调用。
  func必须是一个descriptor或者可调用对象（两个对象都像常规函数一样作为descriptor）。
  当func是一个descriptor(比如普遍的Python函数，classmethod()，staticmethod()，abstractmethod()，或者其
partialmethod实例时，get的调用会委托给底层的descriptor，并返回一个适当的partial对象。
  当func不是可调用的descriptor时，会动态创建一个适当的绑定方法。用于方法时，该行为类似普通的Python函数：self参数会插
入为第一个位置参数，甚至在传递给partialmethod构造器的args和keywords之前。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class Cell(object):
...     def __init__(self):
...         self._alive = False
...     @property
...     def alive(self):
...         return self._alive
...     def set_state(self, state):
...         self._alive = bool(state)
...     set_alive = partialmethod(set_state, True)
...     set_dead = partialmethod(set_state, False)
...
&amp;gt;&amp;gt;&amp;gt; c = Cell()
&amp;gt;&amp;gt;&amp;gt; c.alive
False
&amp;gt;&amp;gt;&amp;gt; c.set_alive()
&amp;gt;&amp;gt;&amp;gt; c.alive
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;functools-reduce-function-iterable-initializer&#34;&gt;functools.reduce(function, iterable[, initializer ])&lt;/h3&gt;

&lt;p&gt;将两个参数的function从左至右依次作用于序列中的项，减少序列为单个值。例如，reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])会计算((((1+2)+3)+4)+5)。左边的参数x是计算出的值，右边的参数y是从序列中更新的值。如果提供了可选参数initializer，在计算中，它会放在序列项之前，当序列为空时，提供一个默认值。如果没指定initializer，并且序列只有包含一项，会返回第一项。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def reduce(function, iterable, initializer=None):
    it = iter(iterable)
    if initializer is None:
        value = next(it)
    else:
        value = initializer
    for element in it:
        value = function(value, element)
    return value
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;functools-singledispatch&#34;&gt;@functools.singledispatch&lt;/h3&gt;

&lt;p&gt;它是是一个key函数，可提供给sorted(), min(), max(), heapq.nlargest(), heapq.nsmallest(), itertools.groupby().等函数使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from functools import singledispatch
&amp;gt;&amp;gt;&amp;gt; @singledispatch
... def fun(arg, verbose=False):
...     if verbose:
...         print(&#39;Let me juset say,&#39;, end=&#39; &#39;)
...     print(arg)
  
使用generic函数的register()属性添加函数的重载实现。这是一个装饰器，接受一个类型参数，并装饰实现该类型操作的函数：
  
&amp;gt;&amp;gt;&amp;gt; @fun.register(int)
... def _(arg, verbose=False):
...    if verbose:
...        print(&#39;Strength in numbers, eh?&#39;, end=&#39; &#39;)
...    print(arg)
...
&amp;gt;&amp;gt;&amp;gt; @fun.register(list)
... def _(arg, verbose=False):
...     if verbose:
...         print(&#39;Enumerate this:&#39;)
...     for i, elem in enumerate(arg):
...         print(i, elem)
  
为了能够注册lambda表达式和预先存在的函数，register()可以用于函数形式：
&amp;gt;&amp;gt;&amp;gt; def nothing(arg, verbose=False):
...     print(&#39;Nothing.&#39;)
...
&amp;gt;&amp;gt;&amp;gt; fun.register(type(None), nothind)
  
register()属性返回未装饰的函数，可以使用装饰堆叠，pickling，以及为每个变体单独创建单元测试：
&amp;gt;&amp;gt;&amp;gt; @fun.register(float)
... @fun.register(Decimal)
... def fun_num(arg, verbose=False):
...     if verbose:
...         print(&#39;Half of your number:&#39;, end=&#39; &#39;)
...     print(arg / 2)
...
&amp;gt;&amp;gt;&amp;gt; fun_num is fun
False
  
调用时，generic函数根据第一个参数的类型dispatch：
&amp;gt;&amp;gt;&amp;gt; fun(&#39;Hello World.&#39;)
Hello World.
&amp;gt;&amp;gt;&amp;gt; fun(&#39;test.&#39;, verbose=True)
Let me just say, test.
&amp;gt;&amp;gt;&amp;gt; fun(42, verbose=True)
Strength in numbers, eh? 42
&amp;gt;&amp;gt;&amp;gt; fun([&#39;spam&#39;, &#39;spam&#39;, &#39;eggs&#39;, &#39;spam&#39;], verbose=True)
Enumerate this:
0 spam
1 spam
2 eggs
3 spam
&amp;gt;&amp;gt;&amp;gt; fun(None)
Nothing.
&amp;gt;&amp;gt;&amp;gt; fun(1.23)
0.615
  
当没有注册特定类型的实现时，其方法解析顺序用于查找更通用的实现。用@singledispatch装饰的原始函数是为object类型注册的，如果没有找到更好的实现，则使用它。
  
使用dispatch()属性查看generic函数为指定类型选择哪个实现：
&amp;gt;&amp;gt;&amp;gt; fun.dispatch(float)
&amp;lt;function fun_num at 0x1035a2840&amp;gt;
&amp;gt;&amp;gt;&amp;gt; fun.dispatch(dict)
&amp;lt;function fun at 0x103fe0000&amp;gt;
  
使用只读属性registry访问所有注册的实现：
&amp;gt;&amp;gt;&amp;gt; fun.registry.keys()
dict_keys([&amp;lt;class &#39;NoneType&#39;&amp;gt;, &amp;lt;class &#39;int&#39;&amp;gt;, &amp;lt;class &#39;object&#39;&amp;gt;,
          &amp;lt;class &#39;decimal.Decimal&#39;&amp;gt;, &amp;lt;class &#39;list&#39;&amp;gt;,
          &amp;lt;class &#39;float&#39;&amp;gt;])
&amp;gt;&amp;gt;&amp;gt; fun.registry[float]
&amp;lt;function fun_num at 0x1035a2840&amp;gt;
&amp;gt;&amp;gt;&amp;gt; fun.registry[object]
&amp;lt;function fun at 0x103fe0000&amp;gt;
  
  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;functools-update-wrapper-wrapper-wrapped-assigned-wrapper-assignments-updated-wrapper-updates&#34;&gt;functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)&lt;/h3&gt;

&lt;p&gt;更新一个wrapper函数，让它看起来像一个wrapped函数。可选参数是元组，用来指定原函数的哪些属性直接分配给wrapper函数的匹配属性，wrapper函数的哪些属性从原函数的相应属性更新。这些参数的默认值是模块级别的常量WRAPPER_ASSIGNMENTS（分配wrapper函数的&lt;strong&gt;module&lt;/strong&gt;，&lt;strong&gt;name&lt;/strong&gt;，&lt;strong&gt;qualname&lt;/strong&gt;，&lt;strong&gt;annotations&lt;/strong&gt;和文档字符串&lt;strong&gt;doc&lt;/strong&gt;）和WRAPPER_UPDATES（哪些更新wrapper函数的&lt;strong&gt;dict&lt;/strong&gt;，比如实例的字典）。&lt;/p&gt;

&lt;p&gt;为了内省和其它目的（比如绕过缓存装饰器lru_cache()）允许访问原始函数，该函数自动在wrapper函数添加一个&lt;strong&gt;wrapped&lt;/strong&gt;属性，应用wrapped函数。&lt;/p&gt;

&lt;p&gt;该函数的主要用途是，在装饰器函数中包装被装饰的函数，并返回wrapper。如果wrapper函数没有更新，返回函数的元数据将反射wrapper的定义，而不是原始函数的定义，原始函数的定义通常没有意义。&lt;/p&gt;

&lt;p&gt;除了函数，update_wrapper()可以与其它可调用对象一起使用。出现在assigned或updated参数中，而不在被包装对象中的任何属性都会被忽略（比如，该函数不会试图在wrapper函数中设置它们）。如果wrapper函数本身缺少updated中的属性，仍然会抛出AttributeError。&lt;/p&gt;

&lt;h3 id=&#34;functools-wraps-wrapped-assigned-wrapper-assignments-updated-wrapper-updates&#34;&gt;@functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)&lt;/h3&gt;

&lt;p&gt;这是一个便捷函数，定义一个wrapper函数时，作为函数装饰器调用update_wrapper()。它等价于partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from functools import wraps
&amp;gt;&amp;gt;&amp;gt; def my_decorator(f):
... @wraps(f)
... def wrapper(*args, **kwds):
... print(&#39;Calling decorated function&#39;)
... return f(*args, **kwds)
... return wrapper
...
&amp;gt;&amp;gt;&amp;gt; @my_decorator
... def example():
... &amp;quot;&amp;quot;&amp;quot;Docstring&amp;quot;&amp;quot;&amp;quot;
... print(&#39;Called example function&#39;)
...
&amp;gt;&amp;gt;&amp;gt; example()
Calling decorated function
Called example function
&amp;gt;&amp;gt;&amp;gt; example.__name__
&#39;example&#39;
&amp;gt;&amp;gt;&amp;gt; example.__doc__
&#39;Docstring&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;partial对象&#34;&gt;partial对象&lt;/h2&gt;

&lt;p&gt;partial()创建可调用的partial对象。它们有三个只读属性：&lt;/p&gt;

&lt;h3 id=&#34;partial-func&#34;&gt;partial.func&lt;/h3&gt;

&lt;p&gt;一个可调用的对象或函数。调用partial对象会转为使用新的参数和关键字参数调用func。&lt;/p&gt;

&lt;h3 id=&#34;partial-args&#34;&gt;partial.args&lt;/h3&gt;

&lt;p&gt;最左边的位置参数会优先作为位置参数提供给partial对象调用。&lt;/p&gt;

&lt;h3 id=&#34;partial-keywords&#34;&gt;partial.keywords&lt;/h3&gt;

&lt;p&gt;partial对象被调用时提供关键字参数。&lt;/p&gt;

&lt;p&gt;partial对象与函数对象类似，它们可以被调用，有弱引用，并且可以有属性。但有一些重要的区别。对于实例，&lt;strong&gt;name&lt;/strong&gt;和&lt;strong&gt;doc&lt;/strong&gt;属性不会自动创建。同时，在类中定义的partial对象的行为类似静态方法，在实例属性查找时，不会转换为绑定方法。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>python itertools详解</title>
      <link>https://buyunhui.github.io/post/python-itertools/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/python-itertools/</guid>
      
        <description>

&lt;h2 id=&#34;itertools&#34;&gt;itertools&lt;/h2&gt;

&lt;h3 id=&#34;api&#34;&gt;api:&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/kVc4SVm.png&#34; alt=&#34;iter1&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/FLPdFvP.png&#34; alt=&#34;Combinatoric&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;itertool-functions&#34;&gt;Itertool functions&lt;/h3&gt;

&lt;h4 id=&#34;itertools-accumulate-iterable-func&#34;&gt;itertools.accumulate(iterable[, func ])&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def accumulate(iterable, func=operator.add):
    &#39;Return running totals&#39;
    # accumulate([1,2,3,4,5]) --&amp;gt; 1 3 6 10 15
    # accumulate([1,2,3,4,5], operator.mul) --&amp;gt; 1 2 6 24 120
    it = iter(iterable)
    try:
        total = next(it)
    except StopIteration:
        return
    yield total
    for element in it:
        total = func(total, element)
        yield total


eg:
&amp;gt;&amp;gt;&amp;gt; data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]
&amp;gt;&amp;gt;&amp;gt; list(accumulate(data, operator.mul)) # running product
[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]
&amp;gt;&amp;gt;&amp;gt; list(accumulate(data, max)) # running maximum
[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]
# Amortize a 5% loan of 1000 with 4 annual payments of 90
&amp;gt;&amp;gt;&amp;gt; cashflows = [1000, -90, -90, -90, -90]
&amp;gt;&amp;gt;&amp;gt; list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt))
[1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-chain-连接多个列表或者迭代器&#34;&gt;itertools.chain 连接多个列表或者迭代器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = itertools.chain(range(3), range(4), [3,2,1])
&amp;gt;&amp;gt;&amp;gt; print(list(x))
[0, 1, 2, 0, 1, 2, 3, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-combinations-求列表或生成器中指定数目的元素不重复的所有组合&#34;&gt;itertools.combinations 求列表或生成器中指定数目的元素不重复的所有组合&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;源码：
def combinations(iterable, r):
    # combinations(&#39;ABCD&#39;, 2) --&amp;gt; AB AC AD BC BD CD
    # combinations(range(4), 3) --&amp;gt; 012 013 023 123
    pool = tuple(iterable)
    n = len(pool)
    if r &amp;gt; n:
        return
    indices = list(range(r))
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != i + n - r:
                break
        else:
            return
        indices[i] += 1
        for j in range(i+1, r):
            indices[j] = indices[j-1] + 1
        yield tuple(pool[i] for i in indices)

def combinations(iterable, r):
    pool = tuple(iterable)
    n = len(pool)
    for indices in permutations(range(n), r):
        if sorted(indices) == list(indices):
            yield tuple(pool[i] for i in indices)

&amp;gt;&amp;gt;&amp;gt; x = itertools.combinations(range(4), 3)
&amp;gt;&amp;gt;&amp;gt; print(list(x))
[(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-combinations-with-replacement-iterable-r-允许重复元素的组合&#34;&gt;itertools.combinations_with_replacement(iterable, r) 允许重复元素的组合&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = itertools.combinations_with_replacement(&#39;ABC&#39;, 2)
&amp;gt;&amp;gt;&amp;gt; print(list(x))
[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;C&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-compress-data-selectors-按照真值表筛选元素&#34;&gt;itertools.compress(data, selectors) 按照真值表筛选元素&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def compress(data, selectors):
    # compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&amp;gt; A C E F
    return (d for d, s in zip(data, selectors) if s)

&amp;gt;&amp;gt;&amp;gt; list(itertools.compress(s,[1,0,1,0,1,1]))
[&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;f&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-count-start-0-step-1&#34;&gt;itertools.count(start=0, step=1)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def count(start=0, step=1):
    # count(10) --&amp;gt; 10 11 12 13 14 ...
    # count(2.5, 0.5) -&amp;gt; 2.5 3.0 3.5 ...
    n = start
    while True:
        yield n
        n += step
&amp;gt;&amp;gt;&amp;gt; x = itertools.count(start=20, step=-1)
&amp;gt;&amp;gt;&amp;gt; print(list(itertools.islice(x, 0, 10, 1)))
[20, 19, 18, 17, 16, 15, 14, 13, 12, 11]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-cycle-iterable-循环指定的列表和迭代器&#34;&gt;itertools.cycle(iterable) 循环指定的列表和迭代器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def cycle(iterable):
    # cycle(&#39;ABCD&#39;) --&amp;gt; A B C D A B C D A B C D ...
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
            yield element

&amp;gt;&amp;gt;&amp;gt; x = itertools.cycle(&#39;ABC&#39;)
&amp;gt;&amp;gt;&amp;gt; print(list(itertools.islice(x, 0, 10, 1)))
[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-dropwhile-predicate-iterable-根据真值表舍弃第一个不满足条件前面的值&#34;&gt;itertools.dropwhile(predicate, iterable) 根据真值表舍弃第一个不满足条件前面的值&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dropwhile(predicate, iterable):
    # dropwhile(lambda x: x&amp;lt;5, [1,4,6,4,1]) --&amp;gt; 6 4 1
    iterable = iter(iterable)
    for x in iterable:
        if not predicate(x):
            yield x
            break
    for x in iterable:
        yield x

&amp;gt;&amp;gt;&amp;gt; x = itertools.dropwhile(lambda e: e &amp;lt; 5, range(10))
&amp;gt;&amp;gt;&amp;gt; print(list(x))
[5, 6, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-filterfalse-保留对应真值为false的元素&#34;&gt;itertools.filterfalse 保留对应真值为False的元素&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def filterfalse(predicate, iterable):
    # filterfalse(lambda x: x%2, range(10)) --&amp;gt; 0 2 4 6 8
    if predicate is None:
        predicate = bool
    for x in iterable:
        if not predicate(x):
            yield x

&amp;gt;&amp;gt;&amp;gt; x = itertools.filterfalse(lambda e: e &amp;lt; 5, (1, 5, 3, 6, 9, 4))
&amp;gt;&amp;gt;&amp;gt; print(list(x))
[5, 6, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-groupby-iterable-key-none-按照分组函数的值对元素进行分组&#34;&gt;itertools.groupby(iterable, key=None) 按照分组函数的值对元素进行分组&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class groupby:
    # [k for k, g in groupby(&#39;AAAABBBCCDAABBB&#39;)] --&amp;gt; A B C D A B
    # [list(g) for k, g in groupby(&#39;AAAABBBCCD&#39;)] --&amp;gt; AAAA BBB CC D
    def __init__(self, iterable, key=None):
        if key is None:
            key = lambda x: x
        self.keyfunc = key
        self.it = iter(iterable)
        self.tgtkey = self.currkey = self.currvalue = object()
    def __iter__(self):
        return self
    def __next__(self):
        self.id = object()
        while self.currkey == self.tgtkey:
            self.currvalue = next(self.it) # Exit on StopIteration
            self.currkey = self.keyfunc(self.currvalue)
        self.tgtkey = self.currkey
    return (self.currkey, self._grouper(self.tgtkey, self.id))
    def _grouper(self, tgtkey, id):
        while self.id is id and self.currkey == tgtkey:
            yield self.currvalue
            try:
                self.currvalue = next(self.it)
            except StopIteration:
                return
            self.currkey = self.keyfunc(self.currvalue)

&amp;gt;&amp;gt;&amp;gt; x = itertools.groupby(range(10), lambda x: x &amp;lt; 5 or x &amp;gt; 8)
&amp;gt;&amp;gt;&amp;gt; for condition, numbers in x:
    print(condition, list(numbers))
True [0, 1, 2, 3, 4]
False [5, 6, 7, 8]
True [9]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-islice-iterable-stop&#34;&gt;itertools.islice(iterable, stop)&lt;/h4&gt;

&lt;h4 id=&#34;itertools-islice-iterable-start-stop-step&#34;&gt;itertools.islice(iterable, start, stop[, step ])&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def islice(iterable, *args):
    # islice(&#39;ABCDEFG&#39;, 2) --&amp;gt; A B
    # islice(&#39;ABCDEFG&#39;, 2, 4) --&amp;gt; C D

    # islice(&#39;ABCDEFG&#39;, 2, None) --&amp;gt; C D E F G
    # islice(&#39;ABCDEFG&#39;, 0, None, 2) --&amp;gt; A C E G
    s = slice(*args)
    it = iter(range(s.start or 0, s.stop or sys.maxsize, s.step or 1))
    try:
        nexti = next(it)
    except StopIteration:
        return
    for i, element in enumerate(iterable):
        if i == nexti:
            yield element
            nexti = next(it)

&amp;gt;&amp;gt;&amp;gt; x = itertools.islice(range(10), 0, 9, 2)
&amp;gt;list(x)
&amp;gt;[0, 2, 4, 6, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-permutations-iterable-r-none-输出输入序列的全排列&#34;&gt;itertools.permutations(iterable, r=None),输出输入序列的全排列&lt;/h4&gt;

&lt;h4 id=&#34;the-number-of-items-returned-is-n-n-r-when-0-r-n-or-zero-when-r-n&#34;&gt;The number of items returned is n! / (n-r)! when 0 &amp;lt;= r &amp;lt;= n or zero when r &amp;gt; n.&lt;/h4&gt;

&lt;h4 id=&#34;根据序列位置进行全排列-而不是值-所以如果输入序列有重复值-输出亦会有&#34;&gt;&lt;strong&gt;根据序列位置进行全排列，而不是值，所以如果输入序列有重复值，输出亦会有&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;源码模拟：
def permutations(iterable, r=None):
    # permutations(&#39;ABCD&#39;, 2) --&amp;gt; AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --&amp;gt; 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r &amp;gt; n:
        return
    indices = list(range(n))
    cycles = list(range(n, n-r, -1))
    yield tuple(pool[i] for i in indices[:r])
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield tuple(pool[i] for i in indices[:r])
                break
    else:
        return
eg:
&amp;gt;&amp;gt;&amp;gt; import itertools as iters
&amp;gt;&amp;gt;&amp;gt; x = iters.permutations([0,1,2], 3)
&amp;gt;&amp;gt;&amp;gt; x
&amp;lt;itertools.permutations object at 0x0000018B993C40A0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; list(x)
[(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]
&amp;gt;&amp;gt;&amp;gt;  x = iters.permutations([0,1,1], 3)
&amp;gt;&amp;gt;&amp;gt; x = iters.permutations([0,1,1], 3)
&amp;gt;&amp;gt;&amp;gt; list(x)
[(0, 1, 1), (0, 1, 1), (1, 0, 1), (1, 1, 0), (1, 0, 1), (1, 1, 0)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-product-iterables-repeat-1-cartesian-product-of-input-iterables&#34;&gt;itertools.product(*iterables, repeat=1) Cartesian product of input iterables.&lt;/h4&gt;

&lt;h4 id=&#34;product-a-b-returns-the-same-as-x-y-for-x-in-a-for-y-in-b&#34;&gt;product(A, B) returns the same as ((x,y) for x in A for y in B)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def product(*args, repeat=1):
    # product(&#39;ABCD&#39;, &#39;xy&#39;) --&amp;gt; Ax Ay Bx By Cx Cy Dx Dy
    # product(range(2), repeat=3) --&amp;gt; 000 001 010 011 100 101 110 111
    pools = [tuple(pool) for pool in args] * repeat
    result = [[]]
    for pool in pools:
        result = [x+[y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)

&amp;gt;&amp;gt;&amp;gt; list(iters.product(&#39;ABC&#39;,repeat =1))
[(&#39;A&#39;,), (&#39;B&#39;,), (&#39;C&#39;,)]
&amp;gt;&amp;gt;&amp;gt; list(iters.product(&#39;ABC&#39;,repeat =2))
[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-repeat-object-times&#34;&gt;itertools.repeat(object[, times ])&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def repeat(object, times=None):
    # repeat(10, 3) --&amp;gt; 10 10 10
    if times is None:
    while True:
        yield object
    else:
        for i in range(times):
            yield object

&amp;gt;&amp;gt;&amp;gt; list(map(pow, range(10), repeat(2)))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-starmap-function-iterable&#34;&gt;itertools.starmap(function, iterable)&lt;/h4&gt;

&lt;h4 id=&#34;map-and-starmap-的区别类似于function-a-b-and-function-c&#34;&gt;map() and starmap()的区别类似于function(a,b) and function(*c).&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def starmap(function, iterable):
    # starmap(pow, [(2,5), (3,2), (10,3)]) --&amp;gt; 32 9 1000
    for args in iterable:
        yield function(*args)

&amp;gt;&amp;gt;&amp;gt; x = itertools.starmap(str.islower, &#39;aBCDefGhI&#39;)
&amp;gt;&amp;gt;&amp;gt; print(list(x))
[True, False, False, False, True, True, False, True, False]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-takewhile-predicate-iterable-保留序列元素直到条件不满足&#34;&gt;itertools.takewhile(predicate, iterable) 保留序列元素直到条件不满足&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def takewhile(predicate, iterable):
    # takewhile(lambda x: x&amp;lt;5, [1,4,6,4,1]) --&amp;gt; 1 4
    for x in iterable:
        if predicate(x):
            yield x
        else:
            break
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-tee-iterable-n-2&#34;&gt;itertools.tee(iterable, n=2)&lt;/h4&gt;

&lt;h4 id=&#34;一旦迭代器被tee-函数分割-就不要再次使用-list-其实更快&#34;&gt;一旦迭代器被tee()函数分割，就不要再次使用；list（）其实更快&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def tee(iterable, n=2):
    it = iter(iterable)
    deques = [collections.deque() for i in range(n)]
    def gen(mydeque):
    while True:
        if not mydeque: # when the local deque is empty
            try:
                newval = next(it) # fetch a new value and
            except StopIteration:
                return
            for d in deques: # load it to all the deques
                d.append(newval)
        yield mydeque.popleft()
    return tuple(gen(d) for d in deques)

&amp;gt;&amp;gt;&amp;gt; x = itertools.tee(range(10), 2)
&amp;gt;&amp;gt;&amp;gt; for letters in x:
... print(list(letters))
...
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;itertools-zip-longest-iterables-fillvalue-none&#34;&gt;itertools.zip_longest(*iterables, fillvalue=None)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def zip_longest(*args, fillvalue=None):
    # zip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;) --&amp;gt; Ax By C- Diterators
    = [iter(it) for it in args]
    num_active = len(iterators)
    if not num_active:
        return
    while True:
        values = []
        for i, it in enumerate(iterators):
                try:
                    value = next(it)
            except StopIteration:
                    num_active -= 1
                    if not num_active:
                        return
                    iterators[i] = repeat(fillvalue)
                    value = fillvalue
            values.append(value)
        yield tuple(values)

&amp;gt;&amp;gt;&amp;gt; x = itertools.zip_longest(range(3), range(5))
&amp;gt;&amp;gt;&amp;gt; y = zip(range(3), range(5))
&amp;gt;&amp;gt;&amp;gt; print(list(x))
[(0, 0), (1, 1), (2, 2), (None, 3), (None, 4)]
&amp;gt;&amp;gt;&amp;gt; print(list(y))
[(0, 0), (1, 1), (2, 2)]

&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>python sort记录</title>
      <link>https://buyunhui.github.io/post/python-sort/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/python-sort/</guid>
      
        <description>

&lt;h2 id=&#34;python-sort&#34;&gt;python sort&lt;/h2&gt;

&lt;h3 id=&#34;1-sorting-basics&#34;&gt;1. Sorting Basics&lt;/h3&gt;

&lt;p&gt;sorted：函数排序副本，不影响原序列&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt;a = [5, 2, 3, 1, 4]  
&amp;gt;&amp;gt;&amp;gt;sorted(a)
[1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; a
[5, 2, 3, 1, 4] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List sort 函数 return None对列表本身进行排序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; &amp;gt;&amp;gt;&amp;gt;a = [5, 2, 3, 1, 4]  
 &amp;gt;&amp;gt;&amp;gt;a
 [1,2,3,4,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both list.sort() and sorted() have a key parameter to specify a function to be called on each list element prior to making comparisons.&lt;br /&gt;
for  dic:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; sorted(&amp;quot;This is a test string from Andrew&amp;quot;.split(), key=str.lower)
 [&#39;a&#39;, &#39;Andrew&#39;, &#39;from&#39;, &#39;is&#39;, &#39;string&#39;, &#39;test&#39;, &#39;This&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; student_tuples = [
... (&#39;john&#39;, &#39;A&#39;, 15),
... (&#39;jane&#39;, &#39;B&#39;, 12),
... (&#39;dave&#39;, &#39;B&#39;, 10),
... ]
&amp;gt;&amp;gt;&amp;gt; sorted(student_tuples, key=lambda student: student[2]) # sort by age
[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for object：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class Student:
... def __init__(self, name, grade, age):
... self.name = name
... self.grade = grade
... self.age = age
... def __repr__(self):
... return repr((self.name, self.grade, self.age))
&amp;gt;&amp;gt;&amp;gt; sorted(student_objects, key=lambda student: student.age) # sort by age
&amp;gt;&amp;gt;&amp;gt;&amp;gt; sorted(student_objects, key=lambda student: student.age) # sort by age
[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-operator-module-functions&#34;&gt;2. Operator Module Functions&lt;/h3&gt;

&lt;p&gt;由于使用key排序非常常见，python提供了内置库operator，更简单更快地进行排序&lt;/p&gt;

&lt;p&gt;eg：  接上面的数据&lt;br /&gt;
for　tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from operator import itemgetter, attrgetter
sorted(student_tuples, key=itemgetter(2))
[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sorted(student_objects, key=attrgetter(&#39;age&#39;))
[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;operator模块允许多级排序：&lt;/strong&gt;
for tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; sorted(student_tuples, key=itemgetter(1,2))
[(&#39;john&#39;, &#39;A&#39;, 15), (&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for boject:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; sorted(student_objects, key=attrgetter(&#39;grade&#39;, &#39;age&#39;))
[(&#39;john&#39;, &#39;A&#39;, 15), (&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-ascending-and-descending&#34;&gt;3. Ascending and Descending&lt;/h3&gt;

&lt;p&gt;Both list.sort() and sorted() accept a reverse parameter with a boolean value. This is used to flag descending sorts. For example, to get the student data in reverse age order:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; sorted(student_tuples, key=itemgetter(2), reverse=True)
[(&#39;john&#39;, &#39;A&#39;, 15), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10)]

&amp;gt;&amp;gt;&amp;gt; sorted(student_objects, key=attrgetter(&#39;age&#39;), reverse=True)
[(&#39;john&#39;, &#39;A&#39;, 15), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-sort-stability-and-complex-sorts&#34;&gt;4.Sort Stability and Complex Sorts&lt;/h3&gt;

&lt;p&gt;排序算法应该是稳定和低复杂度的，利用模块，程序会自动选择最合适的排序算法进行排序&lt;/p&gt;

&lt;p&gt;eg:重复关键字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; data = [(&#39;red&#39;, 1), (&#39;blue&#39;, 1), (&#39;red&#39;, 2), (&#39;blue&#39;, 2)]
&amp;gt;&amp;gt;&amp;gt; sorted(data, key=itemgetter(0))
[(&#39;blue&#39;, 1), (&#39;blue&#39;, 2), (&#39;red&#39;, 1), (&#39;red&#39;, 2)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg:不同属性的排序，age升序，grade降序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = sorted(student_objects, key=attrgetter(&#39;age&#39;)) # sort on secondary key
&amp;gt;&amp;gt;&amp;gt; sorted(s, key=attrgetter(&#39;grade&#39;), reverse=True) # now sort on primary key, descending
[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-using-the-cmp-parameter&#34;&gt;5. Using the cmp Parameter&lt;/h3&gt;

&lt;p&gt;eg：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def numeric_compare(x, y):
... return x - y
&amp;gt;&amp;gt;&amp;gt; sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]

def cmp_to_key(mycmp):
    &#39;Convert a cmp= function into a key= function&#39;
    class K:
    def __init__(self, obj, *args):
    self.obj = obj
    def __lt__(self, other):
    return mycmp(self.obj, other.obj) &amp;lt; 0
    def __gt__(self, other):
    return mycmp(self.obj, other.obj) &amp;gt; 0
    def __eq__(self, other):
    return mycmp(self.obj, other.obj) == 0
    def __le__(self, other):
    return mycmp(self.obj, other.obj) &amp;lt;= 0
    def __ge__(self, other):
    return mycmp(self.obj, other.obj) &amp;gt;= 0
    def __ne__(self, other):
    return mycmp(self.obj, other.obj) != 0
    return K
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Python 3.2, the functools.cmp_to_key() function was added to the functools module in the standard
library.&lt;/p&gt;

&lt;h3 id=&#34;6-use-objects-attri&#34;&gt;6. use objects attri&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; Student.__lt__ = lambda self, other: self.age &amp;lt; other.age
&amp;gt;&amp;gt;&amp;gt; sorted(student_objects)
[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]

&amp;gt;&amp;gt;&amp;gt; newgrades = {&#39;john&#39;: &#39;F&#39;, &#39;jane&#39;:&#39;A&#39;, &#39;dave&#39;: &#39;C&#39;}
&amp;gt;&amp;gt;&amp;gt; sorted(students, key=newgrades.__getitem__)
[&#39;jane&#39;, &#39;dave&#39;, &#39;john&#39;]
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>python 常用函数</title>
      <link>https://buyunhui.github.io/post/python-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/python-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      
        <description>

&lt;h1 id=&#34;python-常用函数&#34;&gt;python 常用函数&lt;/h1&gt;

&lt;h2 id=&#34;1-operator模块&#34;&gt;1.operator模块&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;itemgetter&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;operator.itemgetter(item)
operator.itemgetter(*items)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Return a callable object that fetches item from its operand using the operand’s &lt;strong&gt;getitem&lt;/strong&gt;() method.
If multiple items are specified, returns a tuple of lookup values. For example:
• After f = itemgetter(2), the call f&amp;reg; returns r[2].
• After g = itemgetter(2, 5, 3), the call g&amp;reg; returns (r[2], r[5], r[3]).&lt;/p&gt;

&lt;p&gt;实现源代码（类似）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def itemgetter(*items):
    if len(items) == 1:
        item = items[0]
        def g(obj):
            return obj[item]
    else:
        def g(obj):
          return tuple(obj[item] for item in items)
    return g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;items 可接受任何hashable值，如list，tuple,strings&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#　list
&amp;gt;&amp;gt;&amp;gt; itemgetter(1)(&#39;ABCDEFG&#39;)
&#39;B&#39;
&amp;gt;&amp;gt;&amp;gt; itemgetter(1,3,5)(&#39;ABCDEFG&#39;)

(&#39;B&#39;, &#39;D&#39;, &#39;F&#39;)
&amp;gt;&amp;gt;&amp;gt; itemgetter(slice(2,None))(&#39;ABCDEFG&#39;)
&#39;CDEFG

#　dic
&amp;gt;&amp;gt;&amp;gt; soldier = dict(rank=&#39;captain&#39;, name=&#39;dotterbart&#39;)
&amp;gt;&amp;gt;&amp;gt; itemgetter(&#39;rank&#39;)(soldier)
&#39;captain&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; inventory = [(&#39;apple&#39;, 3), (&#39;banana&#39;, 2), (&#39;pear&#39;, 5), (&#39;orange&#39;, 1)]
&amp;gt;&amp;gt;&amp;gt; getcount = itemgetter(1)
&amp;gt;&amp;gt;&amp;gt; list(map(getcount, inventory))
[3, 2, 5, 1]
&amp;gt;&amp;gt;&amp;gt; sorted(inventory, key=getcount)
[(&#39;orange&#39;, 1), (&#39;banana&#39;, 2), (&#39;apple&#39;, 3), (&#39;pear&#39;, 5)]
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>python 类</title>
      <link>https://buyunhui.github.io/post/python%E7%B1%BB1/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/python%E7%B1%BB1/</guid>
      
        <description>

&lt;h2 id=&#34;python-class&#34;&gt;python Class&lt;/h2&gt;

&lt;h3 id=&#34;1-变量作用域&#34;&gt;&lt;strong&gt;1.变量作用域&lt;/strong&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  在python中，*当前作用域局部变量-&amp;gt;外层作用域变量-&amp;gt;当前模块中的全局变量-&amp;gt;python内置变量*
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def scope_test():
    def do_local():
        spam = &amp;quot;local spam&amp;quot; #此函数定义了另外的一个spam字符串变量，并且生命周期只在此函数内。此处的spam和外层的spam是两个变量，如果写出spam = spam + “local spam” 会报错
    def do_nonlocal():
        nonlocal  spam        #使用外层的spam变量
        spam = &amp;quot;nonlocal spam&amp;quot;
    def do_global():
        global spam
        spam = &amp;quot;global spam&amp;quot;
    spam = &amp;quot;test spam&amp;quot;
    do_local()
    print(&amp;quot;After local assignmane:&amp;quot;, spam)
    do_nonlocal()
    print(&amp;quot;After nonlocal assignment:&amp;quot;,spam)
    do_global()
    print(&amp;quot;After global assignment:&amp;quot;,spam)
 
scope_test()
print(&amp;quot;In global scope:&amp;quot;,spam)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**
上面code的output are:
After local assignmane: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam&lt;/p&gt;

&lt;p&gt;备注：说明： nonlocal适用于在局部函数中的局部函数，把最内层的局部变量设置成外层局部可用，但是还不是全局的。
**&lt;/p&gt;

&lt;h3 id=&#34;2-函数对象&#34;&gt;&lt;strong&gt;2.函数对象&lt;/strong&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;在 Python 中万物皆为对象，函数也不例外，函数作为对象可以赋值给一个变量、可以作为元素添加到集合对象中、可作为参数值传递给其它函数，还可以当做函数的返回值，这些特性就是第一类对象所特有的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;a-函数身为一个对象-拥有对象模型的三个通用属性-id-类型-和值&#34;&gt;a.函数身为一个对象，拥有对象模型的三个通用属性：id、类型、和值。&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
def foo():
    print(&#39;from foo&#39;)
foo()

print(id(foo))
print(type(foo))
print(foo)
输出：
from foo
4406808360
&amp;lt;class &#39;function&#39;&amp;gt;
&amp;lt;function foo at 0x106aa8f28&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;b-函数可以被引用-即函数可以赋值给一个变量&#34;&gt;b.函数可以被引用，即函数可以赋值给一个变量&lt;/h4&gt;

&lt;p&gt;还可以把该函数赋值给更多的变量，唯一变化的是该函数对象的引用计数不断地增加，本质上这些变量最终指向的都是同一个函数对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding:utf-8 -*-
def foo():
    print(&#39;from foo&#39;)

foo()
func=foo    #引用,赋值
print(foo)
print(func)
func()
输出：
from foo
&amp;lt;function foo at 0x10eed8f28&amp;gt;
&amp;lt;function foo at 0x10eed8f28&amp;gt;
from foo
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-函数可以当做参数传递&#34;&gt;c.函数可以当做参数传递&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo():
    print(&#39;from foo&#39;)

def bar(func):
    print(func)
    func()

bar(foo)
输出：
&amp;lt;function foo at 0x000001F77C3A3E18&amp;gt;
from foo

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-函数可以作返回值&#34;&gt;D.函数可以作返回值&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo():
    print(&#39;from foo&#39;)

def bar(func):
    return func     

f=bar(foo)

print(f)

f()
输出：

&amp;lt;function foo at 0x000001F77C3A3E18&amp;gt;
from foo

map,filter,reduce等内置函数
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;e-函数可以当作容器类型的元素&#34;&gt;E.函数可以当作容器类型的元素&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo():
    print(&#39;from foo&#39;)
dic={&#39;func&#39;:foo}
foo()
print(dic[&#39;func&#39;])
dic[&#39;func&#39;]()
输出：
from foo
&amp;lt;function foo at 0x0000024B6D443E18&amp;gt;
from foo
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;f-函数还可以嵌套&#34;&gt;F.函数还可以嵌套&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f1():

    def f2():
        print(&#39;from f2&#39;)
        def f3():
            print(&#39;from f3&#39;)
        f3()
    f2()
f1()
输出：
from f2
from f3

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-类变量与实例变量&#34;&gt;&lt;strong&gt;3.类变量与实例变量&lt;/strong&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):
    count = 0  #类数据属性属于类本身，可以通过类名进行访问/修改
    books = [] # 类数据属性也可以被类的所有实例访问/修改，所以非特殊情 况，请不要定义可变的类数据属性
    def __init__(self, name, age):
        self.name = name  # 实例数据属性只能通过实例访问
        self.age = age  # 实例数据属性只能通过实例访问
    pass
Student.addAttri = &amp;quot;add&amp;quot;; # 在类定义之后，可以通过类名动态添加类数据属性，新增的类属性也被类和所有实例共有
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于可变类型的类属性：
1.可以通过实例进行访问,此时，类属性与实例属性相同
2.当通过实例赋值属性的时候，都将为实例新建一个实例属性，这时类属性与实例属性不一样
3.当通过实例修改类属性的时候，将修改指向的内存地址，此时实例属性与类属性相同&lt;/p&gt;

&lt;h3 id=&#34;4-访问控制&#34;&gt;&lt;strong&gt;4.访问控制&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;1-通过下划线控制-不加下划线表示公有-单下划线表示保护成员-派生类可用-加双下划线表示仅仅类内部可用&#34;&gt;1.通过下划线控制，不加下划线表示公有，单下划线表示保护成员，派生类可用，加双下划线表示仅仅类内部可用&lt;/h4&gt;

&lt;p&gt;如果想要强制访问私有字段，可以通过 【对象._类名&lt;strong&gt;私有字段明 】访问（如：obj._C&lt;/strong&gt;foo），不建议强制访问私有成员。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class C:
    name = &#39;类公有成员&#39;
    _var = &amp;quot;类保护成员&amp;quot;
    __foo = &amp;quot;类私有成员&amp;quot;
    
    def __init__(self):
       self.name = &#39;实例公有成员&#39;
       self.name_var = &amp;quot;实例保护成员&amp;quot;
       self.name__foo = &amp;quot;实例私有成员&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-使用-property-达到成员访问权限控制与参数检查&#34;&gt;2.使用@property，达到成员访问权限控制与参数检查&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError(&#39;Expected a string&#39;)
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError(&amp;quot;Can&#39;t delete attribute&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码中有三个相关联的方法，这三个方法的名字都必须一样。 第一个方法是一个 getter 函数，它使得 first_name 成为一个属性。 其他两个方法给 first_name 属性添加了 setter 和 deleter 函数。 需要强调的是只有在 first_name 属性被创建后， 后面的两个装饰器 @first_name.setter 和 @first_name.deleter 才能被定义。设置了setter实例对象才能对属性值进行更改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个property属性其实就是一系列相关绑定方法的集合。如果你去查看拥有property的类， 就会发现property本身的fget、fset和fdel属性就是类里面的普通方法。比如：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; Person.first_name.fget
&amp;lt;function Person.first_name at 0x1006a60e0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Person.first_name.fset
&amp;lt;function Person.first_name at 0x1006a6170&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Person.first_name.fdel
&amp;lt;function Person.first_name at 0x1006a62e0&amp;gt;
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常来讲，我们写代码不用直接取调用fget或者fset，它们会在访问property的时候自动被触发。&lt;/p&gt;

&lt;p&gt;只有当你确实需要对attribute执行其他额外的操作的时候才应该使用到property。 有时候一些从其他编程语言(比如Java)过来的程序员总认为所有访问都应该通过getter和setter， 所以他们认为代码应该像下面这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要写上面这种没有做任何其他额外操作的property。 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。 其次，它还会让你的程序运行起来变慢很多。&lt;/p&gt;

&lt;p&gt;Properties还是一种定义动态计算attribute的方法。 这种类型的attributes并不会被实际的存储，而是在需要的时候计算出来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import math
class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return math.pi * self.radius ** 2

    @property
    def diameter(self):
        return self.radius * 2

    @property
    def perimeter(self):
        return 2 * math.pi * self.radius
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-创建新的类或实例属性&#34;&gt;5.创建新的类或实例属性&lt;/h3&gt;

&lt;p&gt;如果你想创建一个全新的实例属性，可以通过一个描述器类的形式来定义它的功能。&lt;/p&gt;

&lt;h4 id=&#34;描述器定义&#34;&gt;描述器定义&lt;/h4&gt;

&lt;p&gt;任何函数或者对象定义了一下方法&lt;strong&gt;get&lt;/strong&gt;(), &lt;strong&gt;set&lt;/strong&gt;(), &lt;strong&gt;delete&lt;/strong&gt;()，均称为描述器
python默认的属性调用是对象的&lt;strong&gt;dict&lt;/strong&gt;，对于实例：a.x，调用a.&lt;strong&gt;dict&lt;/strong&gt;[&amp;lsquo;x&amp;rsquo;]，对于类：调用type(a).&lt;strong&gt;dict&lt;/strong&gt;[&amp;lsquo;x&amp;rsquo;]。如果一个对象定义了描述子，则优先调用描述子方法。
1. descr.&lt;strong&gt;get&lt;/strong&gt;(self, obj, type=None) &amp;ndash;&amp;gt; value
1. descr.&lt;strong&gt;set&lt;/strong&gt;(self, obj, value) &amp;ndash;&amp;gt; None
1. descr.&lt;strong&gt;delete&lt;/strong&gt;(self, obj) &amp;ndash;&amp;gt; None&lt;/p&gt;

&lt;h4 id=&#34;描述器分类&#34;&gt;描述器分类&lt;/h4&gt;

&lt;p&gt;数据描述器：同时定义了 &lt;strong&gt;get&lt;/strong&gt;() , &lt;strong&gt;set&lt;/strong&gt;()
非数据描述器：只定义了&lt;strong&gt;get&lt;/strong&gt;()
如果一个实例属性与数据描述器同名，则数据描述器优先，与非数据描述器同名，则实例字典优先
如果定义一个只读数据描述器，将set方法抛出异常
Properties, bound methods, static methods, and class methods are all based on the descriptor protocol.&lt;/p&gt;

&lt;h4 id=&#34;调用流程&#34;&gt;调用流程&lt;/h4&gt;

&lt;p&gt;==&lt;strong&gt;==• descriptors are invoked by the &lt;strong&gt;getattribute&lt;/strong&gt;() method
• overriding &lt;strong&gt;getattribute&lt;/strong&gt;() prevents automatic descriptor calls
• object.&lt;strong&gt;getattribute&lt;/strong&gt;() and type.&lt;strong&gt;getattribute&lt;/strong&gt;() make different calls to &lt;strong&gt;get&lt;/strong&gt;().
• data descriptors always override instance dictionaries.
• non-data descriptors may be overridden by instance dictionaries.==&lt;/strong&gt;==&lt;/p&gt;

&lt;h4 id=&#34;描述器实例&#34;&gt;描述器实例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Descriptor attribute for an integer type-checked attribute
class Integer:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError(&#39;Expected an int&#39;)
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        del instance.__dict__[self.name]

class Point:
    x = Integer(&#39;x&#39;)
    y = Integer(&#39;y&#39;)

    def __init__(self, x, y):
        self.x = x
        self.y = y
        
p = Point(2, 3)
print(p.x)  # Calls Point.x.__get__(p,Point)
p.x = 2.3 # Calls Point.x.__set__(p, 2.3)
p.y = 5 # Calls Point.y.__set__(p, 5)
print(p.y)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;   描述器可实现大部分Python类特性中的底层魔法， 包括 @classmethod 、@staticmethod 、@property ，甚至是 __slots__ 特性。
   通过定义一个描述器，你可以在底层捕获核心的实例操作(get, set, delete)，并且可完全自定义它们的行为。 这是一个强大的工具，有了它你可以实现很多高级功能，并且它也是很多高级库和框架中的重要工具之一。
   描述器的一个比较困惑的地方是它只能在类级别被定义，而不能为每个实例单独定义。
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>python 类继承</title>
      <link>https://buyunhui.github.io/post/%E7%B1%BB%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/%E7%B1%BB%E7%BB%A7%E6%89%BF/</guid>
      
        <description>

&lt;h3 id=&#34;类继承&#34;&gt;类继承&lt;/h3&gt;

&lt;h3 id=&#34;经典类和新式类&#34;&gt;经典类和新式类&lt;/h3&gt;

&lt;p&gt;首先得说明的是,Python的类分为经典类 和 新式类
经典类是python2.2之前的东西,但是在2.7还在兼容,但是在3之后的版本就只承认新式类了(我司很多还是python2.5，XXXXXX)
新式类在python2.2之后的版本中都可以使用&lt;/p&gt;

&lt;h5 id=&#34;0-1经典类和新式类的区别在于&#34;&gt;0.1经典类和新式类的区别在于:&lt;/h5&gt;

&lt;p&gt;1.经典类是默认没有派生自某个基类的,而新式类是默认派生自object这个基类的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# old style
class A():pass
 
# new style
class A(obejct):pass
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.经典类在类多重继承的时候是采用从左到右深度优先原则匹配方法的..而新式类是采用C3算法(不同于广度优先)进行匹配的&lt;/p&gt;

&lt;p&gt;3.经典类是没有&lt;strong&gt;MRO&lt;/strong&gt;和instance.mro()调用的,而新式类是有的.
###1 方法解析顺序 MRO
面向对象中有一个重要特性是继承，如果是单重继承，要调用一个方法，只要按照继承的顺序查找基类即可。但多重继承时，MRO算法的选择（即基类的搜索顺序）非常微妙。
Python先后有三种不同的MRO：经典方式、Python2.2 新式算法、Python2.3 新式算法(C3)。Python 3中只保留了最后一种，即C3算法。
经典方式： 非常简单，深度优先，按定义从左到右
例如：菱形继承结构，按经典方式，d类MRO为&lt;strong&gt;&lt;em&gt;dbaca&lt;/em&gt;&lt;/strong&gt;。缺点是如果c类重写了a类中得方法，c类的方法将不会被调用到。此问题即本地优先顺序问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class a:pass
class b(a):pass
class c(a):pass
class d(b,c):pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新式算法：还是经典方式，但出现重复的，只保留最后一个。上面的例子，MRO为 dbca。问题 单调性。
比如d继承b,c 且b在c的前面。如果f继承d，那么f的mro中也应该和d的一样b在c的前面。单调性即继承时要保持顺序。(dbca)
现在e继承c,b 且c在b的前面(ecba)。f继承d，e时，bc的顺序就没法决定了。无论怎样排都违反了单调性。&lt;/p&gt;

&lt;h3 id=&#34;2-为什么不用经典类-要更换到新式类&#34;&gt;2.为什么不用经典类，要更换到新式类&lt;/h3&gt;

&lt;p&gt;因为在经典类中的多重继承会有些问题…可能导致在继承树中的方法查询绕过后面的父类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class A():
    def foo1(self):
        print &amp;quot;A&amp;quot;
class B(A):
    def foo2(self):
        pass
class C(A):
    def foo1(self):
        print &amp;quot;C&amp;quot;
class D(B, C):
    pass
 
d = D()
d.foo1()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，Base 是父类，A, B 继承自 Base, C 继承自 A, B，它们的继承关系如下：&lt;/p&gt;

&lt;p&gt;按照经典类的查找顺序从左到右深度优先的规则，在访问d.foo1()的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过.&lt;/p&gt;

&lt;p&gt;所以python引入了新式类的概念,每个基类都继承自object并且,他的匹配规则也从深度优先换到了C3&lt;/p&gt;

&lt;h4 id=&#34;c3算法&#34;&gt;C3算法&lt;/h4&gt;

&lt;p&gt;C3算法的一个核心是merge&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在merge列表中，如果第一个序列mro的第一个类是出现在其它序列，并且也是第一个，或者不出现其它序列，那么这个类就会从这些序列中删除，并合到访问顺序列表中
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;L（Child（Base1，Base2）） = [ Child + merge（ L（Base1） ,  L（Base2） ,  Base1Base2 ）]
L（object） = [ object ]
L的性质：结果为列表，列表中至少有一个元素即类自己。
+        ： 添加到列表的末尾，即 [ A + B ] = [ A，B ]
merge： ① 如果列表空则结束，非空 读merge中第一个列表的表头，
               ② 查看该表头是否在 merge中所有列表的表尾中。
               ②--&amp;gt;③ 不在，则 放入 最终的L中，并从merge中的所有列表中删除，然后 回到①中
               ②--&amp;gt;④ 在，查看 当前列表是否是merge中的最后一个列表
               ④--&amp;gt;⑤ 不是 ，跳过当前列表，读merge中下一个列表的表头，然后 回到 ②中
               ④--&amp;gt;⑥ 是，异常。类定义失败。 
表头： 列表的第一个元素
表尾： 列表中表头以外的元素集合（可以为空）

简单原则：
子类永远在父类前面
如果有多个父类，会根据它们在列表中的顺序被检查
如果对下一个类存在两个合法的选择，选择第一个父类
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;super和按照类名访问-混合使用带来的坑&#34;&gt;super和按照类名访问 混合使用带来的坑&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class A(object):
  def __init__(self):
   print &amp;quot;enter A&amp;quot;
   print &amp;quot;leave A&amp;quot;
 
 class B(object):
  def __init__(self):
   print &amp;quot;enter B&amp;quot;
   print &amp;quot;leave B&amp;quot;
 
 class C(A):
  def __init__(self):
   print &amp;quot;enter C&amp;quot;
   super(C, self).__init__()
   print &amp;quot;leave C&amp;quot;
 
 class D(A):
  def __init__(self):
   print &amp;quot;enter D&amp;quot;
   super(D, self).__init__()
   print &amp;quot;leave D&amp;quot;
 class E(B, C):
  def __init__(self):
   print &amp;quot;enter E&amp;quot;
   B.__init__(self)
   C.__init__(self)
   print &amp;quot;leave E&amp;quot;
 
 class F(E, D):
  def __init__(self):
   print &amp;quot;enter F&amp;quot;
   E.__init__(self)
   D.__init__(self)
   print &amp;quot;leave F&amp;quot;
   
 enter F
 enter E
 enter B
 leave B
 enter C
 enter D
 enter A
 leave A
 leave D
 leave C
 leave E
 enter D
 enter A
 leave A
 leave D
 leave F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出来D和A的初始化函数被乱入了两次！
按类名访问就相当于C语言之前的GOTO语句…乱跳,然后再用super按顺序访问..就有问题了&lt;/p&gt;

&lt;p&gt;所以建议就是要么一直用super,要么一直用按照类名访问&lt;/p&gt;

&lt;h3 id=&#34;最佳实现&#34;&gt;最佳实现:&lt;/h3&gt;

&lt;p&gt;避免多重继承
super使用一致
不要混用经典类和新式类
调用父类的时候注意检查类层次&lt;/p&gt;

&lt;h4 id=&#34;super原理简介&#34;&gt;super原理简介&lt;/h4&gt;

&lt;p&gt;super 其实和父类没有实质性的关联。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Base(object):
    def __init__(self):
        print &amp;quot;enter Base&amp;quot;
        print &amp;quot;leave Base&amp;quot;
 
class A(Base):
    def __init__(self):
        print &amp;quot;enter A&amp;quot;
        super(A, self).__init__()
        print &amp;quot;leave A&amp;quot;
 
class B(Base):
    def __init__(self):
        print &amp;quot;enter B&amp;quot;
        super(B, self).__init__()
        print &amp;quot;leave B&amp;quot;
 
class C(A, B):
    def __init__(self):
        print &amp;quot;enter C&amp;quot;
        super(C, self).__init__()
        print &amp;quot;leave C&amp;quot;
        
继承树：
      Base
      /  \
     /    \
    A      B
     \    /
      \  /
       C
       
&amp;gt;&amp;gt;&amp;gt; c = C()
enter C
enter A
enter B
enter Base
leave Base
leave B
leave A
leave C

MRO 列表：
事实上，对于你定义的每一个类，Python 会计算出一个方法解析顺序（Method Resolution Order, MRO）列表，它代表了类继承的顺序，我们可以使用下面的方式获得某个类的 MRO 列表：

&amp;gt;&amp;gt;&amp;gt; C.mro()   # or C.__mro__ or C().__class__.mro()
[__main__.C, __main__.A, __main__.B, __main__.Base, object]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;super实现原理&#34;&gt;super实现原理&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def super(cls, inst):
    mro = inst.__class__.mro()
    return mro[mro.index(cls) + 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，cls 代表类，inst 代表实例，上面的代码做了两件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取 inst 的 MRO 列表&lt;/li&gt;
&lt;li&gt;查找 cls 在当前 MRO 列表中的 index, 并返回它的下一个类，即 mro[index + 1]
当你使用 super(cls, inst) 时，Python 会在 inst 的 MRO 列表上搜索 cls 的下一个类。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在，让我们回到前面的例子。&lt;/p&gt;

&lt;p&gt;首先看类 C 的 &lt;strong&gt;init&lt;/strong&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;super(C, self).__init__()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 self 是当前 C 的实例，self.&lt;strong&gt;class&lt;/strong&gt;.mro() 结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[__main__.C, __main__.A, __main__.B, __main__.Base, object]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，C 的下一个类是 A，于是，跳到了 A 的 &lt;strong&gt;init&lt;/strong&gt;，这时会打印出 enter A，并执行下面一行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;super(A, self).__init__()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这里的 self 也是当前 C 的实例，MRO 列表跟上面是一样的，搜索 A 在 MRO 中的下一个类，发现是 B，于是，跳到了 B 的 &lt;strong&gt;init&lt;/strong&gt;，这时会打印出 enter B，而不是 enter Base。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>python 黑魔法</title>
      <link>https://buyunhui.github.io/post/python%E9%BB%91%E9%AD%94%E6%B3%95/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/python%E9%BB%91%E9%AD%94%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;python-黑魔法&#34;&gt;python 黑魔法&lt;/h2&gt;

&lt;h3 id=&#34;1-上下文管理器&#34;&gt;1、上下文管理器&lt;/h3&gt;

&lt;h4 id=&#34;概述&#34;&gt;概述&lt;/h4&gt;

&lt;p&gt;在正常的管理各种系统资源(文件、锁定和连接)，在涉及到异常时通常是个棘手的问题。异常很可能导致控制流跳过负责释放关键资源的语句。例如打开一个文件进行操作时，如果意外情况发生（磁盘已满、特殊的终端信号让其终止等），就会抛出异常，这样可能最后的文件关闭操作就不会执行。如果这样的问题频繁出现，则可能耗尽系统资源。&lt;/p&gt;

&lt;p&gt;是的，这样的问题并不是不可避免。在没有接触到上下文管理器之前，我们可以用“try/finally”语句来解决这样的问题。或许在有些人看来，“try/finally”语句显得有些繁琐。上下文管理器就是被设计用来简化“try/finally”语句的，这样可以让程序更加简洁。&lt;/p&gt;

&lt;p&gt;平时我们写文件操作代码大概这样,有时候甚至会遗漏释放资源这个步骤&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def m1():
    f = open(&amp;quot;output.txt&amp;quot;, &amp;quot;w&amp;quot;)
    f.write(&amp;quot;python之禅&amp;quot;)
    f.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逻辑厉害的程序员也许会这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def m2():
    f = open(&amp;quot;output.txt&amp;quot;, &amp;quot;w&amp;quot;)
    try:
        f.write(&amp;quot;python之禅&amp;quot;)
    except IOError:
        print(&amp;quot;oops error&amp;quot;)
    finally:
        f.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改良版本的程序是对可能发生异常的代码处进行 try 捕获，使用 try/finally 语句，该语句表示如果在 try 代码块中程序出现了异常，后续代码就不再执行，而直接跳转到 except 代码块。而无论如何，finally 块的代码最终都会被执行。因此，只要把 close 放在 finally 代码中，文件就一定会关闭。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是python已经为我们屌丝程序员考虑到这一点了，提供了上下文管理器，以及with语法糖，上述问题可简写为：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def m3():
    with open(&amp;quot;output.txt&amp;quot;, &amp;quot;w&amp;quot;) as f:
        f.write(&amp;quot;Python之禅&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-1-什么是上下文管理器&#34;&gt;1.1 什么是上下文管理器&lt;/h4&gt;

&lt;p&gt;任何实现了 &lt;strong&gt;__enter__()&lt;/strong&gt; 和 &lt;strong&gt;__exit__()&lt;/strong&gt; 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。显然，文件（file）对象也实现了上下文管理器。&lt;/p&gt;

&lt;p&gt;eg:自定义文件操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class File():
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode

    def __enter__(self):
        &amp;quot;&amp;quot;&amp;quot;
        __enter__() 方法返回资源对象，这里就是你将要打开的那个文件对象
        &amp;quot;&amp;quot;&amp;quot;
        print(&amp;quot;entering&amp;quot;)
        self.f = open(self.filename, self.mode)
        return self.f

    def __exit__(self, *args):
        &amp;quot;&amp;quot;&amp;quot;
        __exit__() 方法处理一些清除工作。
        &amp;quot;&amp;quot;&amp;quot;
        print(&amp;quot;will exit&amp;quot;)
        self.f.close()
&amp;quot;&amp;quot;&amp;quot;
因为 File 类实现了上下文管理器，现在就可以使用 with 语句了。
&amp;quot;&amp;quot;&amp;quot;
with File(&#39;txt.txt&#39;, &#39;w&#39;) as f:
    print(&amp;quot;writing&amp;quot;)
    f.write(&#39;hello, python&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-with语句详解&#34;&gt;1.2 with语句详解&lt;/h4&gt;

&lt;p&gt;通用的上下文语句结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Contextor:
    def __enter__(self):
        pass
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        pass
 
contextor = Contextor()
with contextor [as var]:
    with_body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;with语句执行的大概流程：&lt;/strong&gt;
1. 执行 contextor 以获取上下文管理器
1. 加载上下文管理器的 exit() 方法以备稍后调用
1. 调用上下文管理器的 enter() 方法
1. 如果有 as var 从句，则将 enter() 方法的返回值赋给 var
1. 执行子代码块 with_body
1. 调用上下文管理器的 exit() 方法，如果 with_body 的退出是由异常引发的，那么该异常的 type、value 和 traceback 会作为参数传给 exit()，否则传三个 None
1. 如果 with_body 的退出由异常引发，并且 exit() 的返回值等于 False，那么这个异常将被重新引发一次；如果 exit() 的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码&lt;/p&gt;

&lt;h4 id=&#34;1-3-python提供的上下文管理器&#34;&gt;1.3 python提供的上下文管理器&lt;/h4&gt;

&lt;p&gt;通过实现上下文协议定义创建上下文管理器很方便，Python为了更优雅，还提供了一个 contextmanager 的装饰器，更进一步简化了上下文管理器的实现方式。通过 yield 将函数分割成两部分，yield 之前的语句在 &lt;strong&gt;enter&lt;/strong&gt; 方法中执行，yield 之后的语句在 &lt;strong&gt;exit&lt;/strong&gt; 方法中执行。紧跟在 yield 后面的值是函数的返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from contextlib import contextmanager

@contextmanager
def my_open(path, mode):
    f = open(path, mode)
    yield f
    f.close()


with File(&#39;txt.txt&#39;, &#39;w&#39;) as f:
    print(&amp;quot;writing&amp;quot;)
    f.write(&#39;hello, python&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-迭代器&#34;&gt;2 迭代器&lt;/h3&gt;

&lt;h4 id=&#34;2-1-python-迭代器的大致定义&#34;&gt;2.1 python 迭代器的大致定义&lt;/h4&gt;

&lt;p&gt;简而言之，实现了迭代器协议的对象，就是迭代器。什么是迭代器协议呢？再简而言之，满足下面两个条件即可：&lt;/p&gt;

&lt;p&gt;实现了魔法方法 &lt;strong&gt;iter&lt;/strong&gt;()，返回一个迭代对象，这个对象有一个next()方法，
实现 next() 方法，返回当前的元素，并指向下一个元素的位置，当前位置已经没有元素的时候，抛出StopIteration异常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ReverseList(object):

    def __init__(self, item):
        self.list = list(range(item))

    def __iter__(self):
        return self

    def next(self):

        try:
            return self.list.pop()
        except:
            raise StopIteration


it = ReverseList(5)
print(it.next()) # 4
print(it.next()) # 3
print(it.next()) # 2
print(it.next()) # 1
print(it.next()) # 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于迭代器，python还有很多高级功能，并且还专门有一个itertools标准库用来做迭代器对象的相关处理。&lt;/p&gt;

&lt;h3 id=&#34;3-生成器&#34;&gt;3. 生成器&lt;/h3&gt;

&lt;h4 id=&#34;3-1-生成器-generator-概念&#34;&gt;3.1 生成器(generator)概念&lt;/h4&gt;

&lt;p&gt;生成器不会把结果保存在一个系列中，而是保存生成器的状态，在每次进行迭代时返回一个值，直到遇到StopIteration异常结束。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;生成器语法：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;生成器表达式： 通列表解析语法，只不过把列表解析的[]换成()
生成器表达式能做的事情列表解析基本都能处理，只不过在需要处理的序列比较大时，列表解析比较费内存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;L = [x * x for x in range(10)]  # list
print L # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

g = (x * x for x in range(10))  # 生成器
print g # &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x000002061928A6D0&amp;gt;

# 如果要一个一个打印出来，可以通过generator的next()方法：
print g.next() # 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-2-生成器函数&#34;&gt;3.2 生成器函数&lt;/h4&gt;

&lt;p&gt;在函数中如果出现了yield关键字，那么该函数就不再是普通函数，而是生成器函数。但是生成器函数可以生产一个无线的序列，这样列表根本没有办法进行处理。&lt;/p&gt;

&lt;p&gt;yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator。
下面为一个可以无穷生产奇数的生成器函数。&lt;strong&gt;(生成器是包含有&lt;strong&gt;iter()和next&lt;/strong&gt;()方法的)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def odd():
    n = 0
    while True:
        yield n
        n += 2

odd_num = odd()
count = 0

for o in odd_num:
    if count &amp;gt;= 5:
        break
    print(o)
    count += 1
output:
0 2 4 6 8
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-3yield-与-return&#34;&gt;3.3yield 与 return&lt;/h4&gt;

&lt;p&gt;在一个生成器中，如果没有return，则默认执行到函数完毕时返回StopIteration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def g1():
...     yield 1
...
&amp;gt;&amp;gt;&amp;gt; g=g1()
&amp;gt;&amp;gt;&amp;gt; next(g)    #第一次调用next(g)时，会在执行完yield语句后挂起，所以此时程序并没有执行结束。
1
&amp;gt;&amp;gt;&amp;gt; next(g)    #程序试图从yield语句的下一条语句开始执行，发现已经到了结尾，所以抛出StopIteration异常。
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;如果遇到return,如果在执行过程中 return，则直接抛出 StopIteration&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def g2():
...     yield &#39;a&#39;
...     return
...     yield &#39;b&#39;
...
&amp;gt;&amp;gt;&amp;gt; g=g2()
&amp;gt;&amp;gt;&amp;gt; next(g)    #程序停留在执行完yield &#39;a&#39;语句后的位置。
&#39;a&#39;
&amp;gt;&amp;gt;&amp;gt; next(g)    #程序发现下一条语句是return，所以抛出StopIteration异常，这样yield &#39;b&#39;语句永远也不会执行。
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-4-生成器支持的方法&#34;&gt;3.4 生成器支持的方法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; help(odd_num)
Help on generator object:
 
odd = class generator(object)
 |  Methods defined here:
 ......
 |  close(...)
 |      close() -&amp;gt; raise GeneratorExit inside generator.
 |
 |  send(...)
 |      send(arg) -&amp;gt; send &#39;arg&#39; into generator,
 |      return next yielded value or raise StopIteration.
 |
 |  throw(...)
 |      throw(typ[,val[,tb]]) -&amp;gt; raise exception in generator,
 |      return next yielded value or raise StopIteration.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-4-1-close&#34;&gt;3.4.1 close()&lt;/h5&gt;

&lt;p&gt;手动关闭生成器函数，后面的调用会直接返回StopIteration异常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def g4():
...     yield 1
...     yield 2
...     yield 3
...
&amp;gt;&amp;gt;&amp;gt; g=g4()
&amp;gt;&amp;gt;&amp;gt; next(g)
1
&amp;gt;&amp;gt;&amp;gt; g.close()
&amp;gt;&amp;gt;&amp;gt; next(g)    #关闭后，yield 2和yield 3语句将不再起作用
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-4-2-send&#34;&gt;3.4.2 send()&lt;/h4&gt;

&lt;p&gt;生成器函数最大的特点是可以接受外部传入的一个变量，并根据变量内容计算结果后返回。
这是生成器函数最难理解的地方，也是最重要的地方，实现后面我会讲到的协程就全靠它了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def gen():
    value=0
    while True:
        receive=yield value
        if receive==&#39;e&#39;:
            break
        value = &#39;got: %s&#39; % receive
 
g=gen()
print(g.send(None))     
print(g.send(&#39;aaa&#39;))
print(g.send(3))
print(g.send(&#39;e&#39;))

got: aaa
got: 3
Traceback (most recent call last):
File &amp;quot;h.py&amp;quot;, line 14, in &amp;lt;module&amp;gt;
  print(g.send(&#39;e&#39;))
StopIteration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过g.send(None)或者next(g)可以启动生成器函数，并执行到第一个yield语句结束的位置。此时，执行完了yield语句，但是没有给receive赋值。yield value会输出初始值0注意：在启动生成器函数时只能send(None),如果试图输入其它的值都会得到错误提示信息。&lt;/li&gt;
&lt;li&gt;通过g.send(‘aaa’)，会传入aaa，并赋值给receive，然后计算出value的值，并回到while头部，执行yield value语句有停止。此时yield value会输出”got: aaa”，然后挂起。&lt;/li&gt;
&lt;li&gt;通过g.send(3)，会重复第2步，最后输出结果为”got: 3″&lt;/li&gt;
&lt;li&gt;当我们g.send(‘e’)时，程序会执行break然后推出循环，最后整个函数执行完毕，所以会得到StopIteration异常。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;3-4-2-throw&#34;&gt;3.4.2 throw()&lt;/h4&gt;

&lt;p&gt;用来向生成器函数送入一个异常，可以结束系统定义的异常，或者自定义的异常。
throw()后直接跑出异常并结束程序，或者消耗掉一个yield，或者在没有下一个yield的时候直接进行到程序的结尾。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def gen():
    while True: 
        try:
            yield &#39;normal value&#39;
            yield &#39;normal value 2&#39;
            print(&#39;here&#39;)
        except ValueError:
            print(&#39;we got ValueError here&#39;)
        except TypeError:
            break
 
g=gen()
print(next(g))
print(g.throw(ValueError))
print(next(g))
print(g.throw(TypeError))

normal value
we got ValueError here
normal value
normal value 2
Traceback (most recent call last):
  File &amp;quot;h.py&amp;quot;, line 15, in &amp;lt;module&amp;gt;
    print(g.throw(TypeError))
StopIteration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;print(next(g))：会输出normal value，并停留在yield ‘normal value 2’之前。&lt;/li&gt;
&lt;li&gt;由于执行了g.throw(ValueError)，所以会跳过所有后续的try语句，也就是说yield ‘normal value 2’不会被执行，然后进入到except语句，打印出we got ValueError here。然后再次进入到while语句部分，消耗一个yield，所以会输出normal value。&lt;/li&gt;
&lt;li&gt;print(next(g))，会执行yield ‘normal value 2’语句，并停留在执行完该语句后的位置。&lt;/li&gt;
&lt;li&gt;g.throw(TypeError)：会跳出try语句，从而print(‘here’)不会被执行，然后执行break语句，跳出while循环，然后到达程序结尾，所以跑出StopIteration异常&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;3-5-生成器总结&#34;&gt;3.5 生成器总结&lt;/h3&gt;

&lt;p&gt;综合例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def flatten(nested):
    try:
        # 如果是字符串，那么手动抛出TypeError。
        if isinstance(nested, str):
            raise TypeError
        for sublist in nested:
            # yield flatten(sublist)
            for element in flatten(sublist):
                # yield element
                print(&#39;got:&#39;, element)
    except TypeError:
        print(&#39;here&#39;)
        yield nested


L = [&#39;aaadf&#39;, [1, 2, 3], 2, 4, [5, [6, [8, [9]], &#39;ddf&#39;], 7]]

for num in flatten(L):
    print(num)
    
here
got: aaadf
here
got: 1
here
got: 2
here
got: 3
here
got: 2
here
got: 4
here
got: 5
here
got: 6
here
got: 8
here
got: 9
here
got: ddf
here
got: 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照鸭子模型理论，生成器就是一种迭代器，可以使用for进行迭代。
第一次执行next(generator)时，会执行完yield语句后程序进行挂起，所有的参数和状态会进行保存。再一次执行next(generator)时，会从挂起的状态开始往后执行。在遇到程序的结尾或者遇到StopIteration时，循环结束。
可以通过generator.send(arg)来传入参数，这是协程模型。
可以通过generator.throw(exception)来传入一个异常。throw语句会消耗掉一个yield。可以通过generator.close()来手动关闭生成器。
next()等价于send(None)&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>python类的定制</title>
      <link>https://buyunhui.github.io/post/python%E5%AE%9A%E5%88%B6%E7%B1%BB/</link>
      <pubDate>Sun, 15 Apr 2018 14:57:23 +0800</pubDate>
      
      <guid>https://buyunhui.github.io/post/python%E5%AE%9A%E5%88%B6%E7%B1%BB/</guid>
      
        <description>

&lt;h2 id=&#34;python定制类&#34;&gt;python定制类&lt;/h2&gt;

&lt;h4 id=&#34;1-python中-getattribute-vs-getattr-vs-get浅谈&#34;&gt;1.Python中 &lt;strong&gt;getattribute&lt;/strong&gt; vs &lt;strong&gt;getattr&lt;/strong&gt; vs get浅谈&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;__get__, __getattr__和__getattribute都是访问属性的方法，但不太相同。object.__getattr__(self, name) 当一般位置找不到attribute的时候，会调用getattr，返回一个值或AttributeError异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__getattribute__(self, name)
无条件被调用，通过实例访问属性。如果class中定义了__getattr__()，则__getattr__()不会被调用（除非显示调用或引发AttributeError异常）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__get__(self, instance, owner) 如果class定义了它，则这个class就可以称为descriptor。owner是所有者的类，instance是访问descriptor的实例，如果不是通过实例访问，而是通过类访问的话，instance则为None。（descriptor的实例自己访问自己是不会触发__get__，而会触发__call__，只有descriptor作为其它类的属性才有意义。）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;2-方法总览&#34;&gt;2. 方法总览&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;基础方法：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C.&lt;strong&gt;new&lt;/strong&gt;(self[,arg1,…])        构造器（带一些可选的参数）；通常用在设置不可变数据类型的子类
C.&lt;strong&gt;del&lt;/strong&gt;(self)        解构器
C.&lt;strong&gt;str&lt;/strong&gt;(self)        可打印的字符串输出；内建 str() 及 print() 函数
C.&lt;strong&gt;repr&lt;/strong&gt;(self)        运行时的字符串输出；内建 repr() 函数及 &amp;lsquo; &amp;rsquo; 操作符
C.&lt;strong&gt;call&lt;/strong&gt;(self,*args)        用于可调用的实例；可以用来替代闭包的实现
C.&lt;strong&gt;nonezero&lt;/strong&gt;(self)        为实例定义 False 值；内建 bool() 函数
C.&lt;strong&gt;len&lt;/strong&gt;(self)        长度；内建 len()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类的值比较：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C.&lt;strong&gt;cmp&lt;/strong&gt;(self,obj)        对象比较；内建 cmp()
C.&lt;strong&gt;lt&lt;/strong&gt;(self,obj) &amp;amp; C.&lt;strong&gt;le&lt;/strong&gt;(self,obj)        小于或小于等于；内建&amp;lt; &amp;amp; &amp;lt;=
C.&lt;strong&gt;gt&lt;/strong&gt;(self,obj) &amp;amp; C.&lt;strong&gt;ge&lt;/strong&gt;(self,obj)        大于或大于等于；内建 &amp;gt; &amp;amp; &amp;gt;=
C.&lt;strong&gt;eq&lt;/strong&gt;(self,obj) &amp;amp; C.&lt;strong&gt;ne&lt;/strong&gt;(self,obj)        等于或不等于；内建 = &amp;amp; ！=
&lt;strong&gt;类的属性：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C.&lt;strong&gt;getattr&lt;/strong&gt;(self,attr)        获取属性；内建 getattr()；仅在属性没有找到时调用
C.&lt;strong&gt;setattr&lt;/strong&gt;(self,attr)        设置属性
C.&lt;strong&gt;delattr&lt;/strong&gt;(self,attr)        删除属性
C.&lt;strong&gt;getattribute&lt;/strong&gt;(self,attr)        获取属性；内建 getattr()；总是被调用
C.&lt;strong&gt;get&lt;/strong&gt;(self,attr)        （描述符）获取属性
C.&lt;strong&gt;set&lt;/strong&gt;(self,attr)        （描述符）设置属性
C.&lt;strong&gt;delete&lt;/strong&gt;(self,attr)        （描述符）删除属性
&lt;strong&gt;数值类型，二进制操作符：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C.&lt;strong&gt;*add&lt;/strong&gt;(self,obj)        加；+ 操作符
C.&lt;strong&gt;*sub&lt;/strong&gt;(self,obj)        减；+ 操作符
C.&lt;strong&gt;*mul&lt;/strong&gt;(self,obj)        乘；* 操作符
C.&lt;strong&gt;*dev&lt;/strong&gt;(self,obj)        除；/ 操作符
C.&lt;strong&gt;*truediv&lt;/strong&gt;(self,obj)        真正的除法；/ 操作符
C.&lt;strong&gt;*floordiv&lt;/strong&gt;(self,obj)        地板除；// 操作符
C.&lt;strong&gt;*mod&lt;/strong&gt;(self,obj)        取模；% 操作符
C.&lt;strong&gt;*divmod&lt;/strong&gt;(self,obj)        除和取模；内建 divmod()
C.&lt;strong&gt;*pow&lt;/strong&gt;(self,obj[,mod])        乘幂；内建 pow() ; ** 操作符
C.&lt;strong&gt;*lshift&lt;/strong&gt;(self,obj)        左移位；&amp;lt;&amp;lt; 操作符
C.&lt;strong&gt;*rshift&lt;/strong&gt;(self,obj)        右移位；&amp;gt;&amp;gt; 操作符
C.&lt;strong&gt;*and&lt;/strong&gt;(self,obj)        按位与；&amp;amp; 操作符
C.&lt;strong&gt;*or&lt;/strong&gt;(self,obj)        按位或；| 操作符
C.&lt;strong&gt;*xor&lt;/strong&gt;(self,obj)        按位异或；^ 操作符
&lt;strong&gt;数值类型，一元操作符：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C.&lt;strong&gt;neg&lt;/strong&gt;(self)        一元负
C.&lt;strong&gt;pos&lt;/strong&gt;(self)        一元正
C.&lt;strong&gt;abs&lt;/strong&gt;(self)        绝对值；内建 abs()
C.&lt;strong&gt;invert&lt;/strong&gt;(self)        按位求反；内建 ~ 操作符
&lt;strong&gt;数值类型，数值转换：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C.&lt;strong&gt;complex&lt;/strong&gt;(self, com)        内建 complex()
C.&lt;strong&gt;int&lt;/strong&gt;(self)        内建 int()
C.&lt;strong&gt;float&lt;/strong&gt;(self)        内建 float()
&lt;strong&gt;数值类型，数值压缩：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C.&lt;strong&gt;index&lt;/strong&gt;(self)        在有必要时，压缩可选的数值类型为整型（比如用于切片索引时等）
&lt;strong&gt;序列类型：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C.&lt;strong&gt;len&lt;/strong&gt;(self)        序列中的项目数
C.&lt;strong&gt;getitem&lt;/strong&gt;(self, ind)        获取一个元素
C.&lt;strong&gt;setitem&lt;/strong&gt;(self, ind,val)        设置一个元素
C.&lt;strong&gt;delitem&lt;/strong&gt;(self, ind)        删除一个元素
C.&lt;strong&gt;getslice&lt;/strong&gt;(self, ind1,ind2)        获取切片元素
C.&lt;strong&gt;setslice&lt;/strong&gt;(self, i1, i2,val)        设置切片元素
C.&lt;strong&gt;delslice&lt;/strong&gt;(self, ind1,ind2)        删除切片元素
C.&lt;strong&gt;contains&lt;/strong&gt;(self, val)        含有成员；内建 in 关键字
C.&lt;strong&gt;*add&lt;/strong&gt;(self,obj)        串联；+ 操作符
C.&lt;strong&gt;*mul&lt;/strong&gt;(self,obj)        重复；* 操作符
C.&lt;strong&gt;iter&lt;/strong&gt;(self)        生成迭代器；内建 iter() 函数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;映射类型：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C.&lt;strong&gt;len&lt;/strong&gt;(self)        类中的项目数
C.&lt;strong&gt;hash&lt;/strong&gt;(self)        散列（hash）函数值
C.&lt;strong&gt;getitem&lt;/strong&gt;(self,key)        获取某个值
C.&lt;strong&gt;setitem&lt;/strong&gt;(self,key,val)        设置某个值
C.&lt;strong&gt;delitem&lt;/strong&gt;(self,key)        删除某个值
C.&lt;strong&gt;missing&lt;/strong&gt;(self,key)        给定键若不存在，则返回一个默认值&lt;/p&gt;

&lt;h3 id=&#34;3-new-init-call-的介绍&#34;&gt;3. &lt;strong&gt;new&lt;/strong&gt;、&lt;strong&gt;init&lt;/strong&gt;、&lt;strong&gt;call&lt;/strong&gt;的介绍&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;__new__方法负责创建一个实例对象，在对象被创建的时候调用该方法它是一个类方法。__new__方法在返回一个实例之后，会自动的调用__init__方法，对实例进行初始化。如果__new__方法不返回值，或者返回的不是实例，那么它就不会自动的去调用__init__方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;__init__ 方法负责将该实例对象进行初始化，在对象被创建之后调用该方法，在__new__方法创建出一个实例后对实例属性进行初始化。__init__方法可以没有返回值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;__call__方法其实和类的创建过程和实例化没有多大关系了，定义了__call__方法才能被使用函数的方式执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding:utf-8
class Foo(object):
    def __new__(cls, *args, **kwargs):
        #__new__是一个类方法，在对象创建的时候调用
        print &amp;quot;excute __new__&amp;quot;
        return super(Foo,cls).__new__(cls,*args,**kwargs)


    def __init__(self,value):
        #__init__是一个实例方法，在对象创建后调用，对实例属性做初始化
        print &amp;quot;excute __init&amp;quot;
        self.value = value


f1 = Foo(1)
print f1.value
f2 = Foo(2)
print f2.value

#输出===：
excute __new__
excute __init
excute __new__
excute __init
#====可以看出new方法在init方法之前执行
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://buyunhui.github.io/post/1%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://buyunhui.github.io/post/1%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      
        <description>

&lt;h2 id=&#34;python-装饰器&#34;&gt;python 装饰器&lt;/h2&gt;

&lt;p&gt;现在需要在函数运行前后打印一条日志, 但是又不希望或者没有权限修改函数内部的结构, 就可以用到装饰器(decorator):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def log(function):

    def wrapper(*args, **kwargs):

        print &#39;before function [%s()] run.&#39; % function.__name__

        rst = function(*args, **kwargs)

        print &#39;after function [%s()] run.&#39; % function.__name__

        return rst

    return wrapper 



@log

def func():

    print &#39;func() run.&#39;



output：

before function [func()] run.

func() run.

after function [func()] run.

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-函数装饰器&#34;&gt;1.函数装饰器&lt;/h3&gt;

&lt;h4 id=&#34;1-1-无参数装饰器&#34;&gt;1.1 无参数装饰器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def outer(some_func):

    def inner():

        print(&amp;quot;before some_func&amp;quot;)

        ret = some_func() # 1

        return ret + 1

    return inner



def foo():

    return 1

decorater = outer(foo)

print(decorater())



output:

before some_func

2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**使用@&lt;/p&gt;

&lt;p&gt;@outer等价 decorater = outer(foo) **&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
@outer

def foo1():

    return 1

print(foo1())



output:

before some_func

2

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-装饰函数有参数-args-和-kwargs&#34;&gt;1.2 装饰函数有参数（ args 和 *kwargs）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;*args 只在定义函数时用来表示位置参数将会保存在变量 args 中。Python 也允许指定一些变量，并捕获任何在 args 里的额外参数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;（*）符号也可以用在函数调用时，在这里它也有类似的意义。在调用函数时，以 * 开头的变量表示该变量内容需被取出用做位置参数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&amp;gt;&amp;gt;&amp;gt; def add(x, y):

...     return x + y

&amp;gt;&amp;gt;&amp;gt; lst = [1,2]

&amp;gt;&amp;gt;&amp;gt; add(lst[0], lst[1]) # 1

3

&amp;gt;&amp;gt;&amp;gt; add(*lst) # 2

3



&amp;gt;&amp;gt;&amp;gt; def foo(**kwargs):

...     print kwargs

&amp;gt;&amp;gt;&amp;gt; foo()

{}

&amp;gt;&amp;gt;&amp;gt; foo(x=1, y=2)

{&#39;y&#39;: 2, &#39;x&#39;: 1}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当定义一个函数时，使用 **kwargs 来表示所有未捕获的关键字参数将会被存储在字典 kwargs 中。此前 args 和 kwargs 都不是 Python 中语法的一部分，但在函数定义时使用这两个变量名是一种惯例。和 * 的使用一样，可以在函数调用和定义时使用 **。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&amp;gt;&amp;gt;&amp;gt; dct = {&#39;x&#39;: 1, &#39;y&#39;: 2}

&amp;gt;&amp;gt;&amp;gt; def bar(x, y):

...     return x + y

&amp;gt;&amp;gt;&amp;gt; bar(**dct)

3

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-3-装饰器本身有参数&#34;&gt;1.3 装饰器本身有参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def log(text=&#39;&#39;):

    def decorator(function):

        @functools.wraps(function)

        def wrapper(*args, **kwargs):

            print &#39;before function [%s()] run, text: [%s].&#39; % (function.__name__, text)

            rst = function(*args, **kwargs)

            print &#39;after function [%s()] run, text: [%s].&#39; % (function.__name__, text)

            return rst 

        return wrapper

    return decorator



@log(&#39;log text&#39;)

def func():

    print &#39;func() run.&#39;



output:

before function [func()] run.

func() run.

after function [func()] run.



def external_function(i, j):

    k = i - j

    def decorator(func):

        def wrapper(*arg):

            print(&#39;this func is %s&#39;%(func.__name__))

            print(k * func(*arg))

        return wrapper

    return decorator



@external_function(10,5)

def my_func(x,y):

    return x + y



if __name__ == &#39;__main__&#39;:

    my_func(10, 2)



this func is my_func

60

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-4-装饰器调用顺序&#34;&gt;1.4 装饰器调用顺序&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def dec1(func):

    print(&amp;quot;entry dec1&amp;quot;)

    def wapper(a, b):

        print(&amp;quot;enter dec1 wapper&amp;quot;)

        func(a,b)

    return wapper

    

def dec2(func):

    print(&amp;quot;entry dec2&amp;quot;)

    def wapper2(a, b):

        print(&amp;quot;enter dec2 wapper&amp;quot;)

        func(a,b)

    return wapper2



@dec1

@dec2

def Add(a, b):

    print(a + b)

    

Add(1, 2)



output:



entry dec2

entry dec1

enter dec1 wapper

enter dec2 wapper

3

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考上面例子，首先执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
@dec2

def Add(a, b):

    print(a + b)

    

返回

dec2函数的wapper2

接着执行

@dec1

wapper2

接着执行dec1的wapper函数，wapper2作为func参数传入最后执行

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-5装饰器会改变函数签名&#34;&gt;1.5装饰器会改变函数签名&lt;/h4&gt;

&lt;p&gt;使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
ef logged(func):

    def with_logging(*args, **kwargs):

        &amp;quot;with_logging&amp;quot;

        print(func.__name__ + &amp;quot; was called&amp;quot;)

        return func(*args, **kwargs)

    return with_logging



@logged

def f(x):

    &amp;quot;&amp;quot;&amp;quot;does some math&amp;quot;&amp;quot;&amp;quot;

    return x + x * x

if __name__ == &#39;__main__&#39;:

    f(2)

    print(f.__name__) # prints &#39;with_logging&#39;)

    print(f.__doc__ )# prints with_logging)

 

@logged

def f(x)



等价于 f = logged(f)

锁函数f被with_logging所代替了，相应的doc,__name__等属性也就被代替了



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-类装饰器&#34;&gt;2.类装饰器&lt;/h3&gt;

&lt;p&gt;相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器还可以依靠类内部的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。&lt;/p&gt;

&lt;h4 id=&#34;2-1-不带参数的类装饰器&#34;&gt;2.1 不带参数的类装饰器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Foo(object):

    def __init__(self, func):

        self._func = func

        

    def __call__(self):

        print(&amp;quot;class decorater runing&amp;quot;)

        self._func()

        print(&amp;quot;class decorater runing&amp;quot;)       

@Foo

def bar():

    print(&amp;quot;bar&amp;quot;)

    

output:

class decorater runing

bar

class decorater runing

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;@Foo

def bar(): 等价于 bar = Foo(bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-带参数的类装饰器&#34;&gt;2.2 带参数的类装饰器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class tracer:  



    def __init__(self, *args):  

        self.calls = 0

        self.args = args



    def __call__(self, func):

        self.func = func

        def realfunc(*args):

              self.calls += 1

              print(&#39;call %s to %s&#39; %(self.calls, self.func.__name__))

              self.func(*args)

        return realfunc



@tracer(&amp;quot;xxxx&amp;quot;)

def spam(a, b, c):   

    print(a + b + c)  



if __name__ == &#39;__main__&#39;:

    spam(1,2,3)

    

output:

call 1 to spam

6

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-函数装饰器修饰类方法&#34;&gt;3. 函数装饰器修饰类方法&lt;/h3&gt;

&lt;p&gt;有一个类Test, 它的结构如下:现在我需要捕获一个异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Test(object):

    def __init__(self):

        pass



    def revive(self):

        print(&#39;revive from exception.&#39;)

        # do something to restore



    def read_value(self):

        print(&#39;here I will do something.&#39;)

        # do something.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用装饰器来解决这个问题，装饰器函数应该写在类里面还是类外面呢？答案是，写在类外面。那么既然写在类外面，如何调用这个类的其他方法呢？&lt;/p&gt;

&lt;p&gt;首先写出一个最常见的处理异常的装饰器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def catch_exception(origin_func):

    def wrapper(*args, **kwargs):

        try:

            u = origin_func(*args, **kwargs)

            return u

        except Exception:

            return &#39;an Exception raised.&#39;

    return wrapper





class Test(object):

    def __init__(self):

        pass



    def revive(self):

        print(&#39;revive from exception.&#39;)

        # do something to restore



    @catch_exception

    def read_value(self):

        print(&#39;here I will do something.&#39;)

        # do something.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法，确实可以捕获到origin_func()的异常，但是如果在发生异常的时候，需要调用类里面的另一个方法来处理异常，这又应该怎么办？答案是给wrapper增加一个参数：self.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def catch_exception(origin_func):

    def wrapper(self, *args, **kwargs):

        try:

            u = origin_func(self, *args, **kwargs)

            return u

        except Exception:

            self.revive() #不用顾虑，直接调用原来的类的方法

            return &#39;an Exception raised.&#39;

    return wrapper





class Test(object):

    def __init__(self):

        pass



    def revive(self):

        print(&#39;revive from exception.&#39;)

        # do something to restore



    @catch_exception

    def read_value(self):

        print(&#39;here I will do something.&#39;)

        sada # 人造异常

        # do something.





if __name__ == &#39;__main__&#39;:

    test = Test()

    test.read_value()

    

output:

here I will do something.

revive from exception.

&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://buyunhui.github.io/post/python%E5%85%83%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://buyunhui.github.io/post/python%E5%85%83%E7%B1%BB/</guid>
      
        <description>

&lt;h2 id=&#34;python元类&#34;&gt;python元类&lt;/h2&gt;

&lt;h3 id=&#34;1-在python中-一切皆对象&#34;&gt;1. 在python中，一切皆对象&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ObjectCreator(object):
     pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是你可以对它做如下的操作：可以将它赋值给一个变量， 你可以拷贝它， 你可以为它增加属性， 你可以将它作为函数参数进行传递,也可以返回一个类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def choose_class(name):
    if name == &#39;foo&#39;:
        class Foo(object):
            pass
        return Foo     # 返回的是类，不是类的实例
    else:
        class Bar(object):
            pass
        return Bar
MyClass = choose_class(&#39;foo&#39;)

print MyClass              # 函数返回的是类，不是类的实例
#输出：&amp;lt;class &#39;__main__.Foo&#39;&amp;gt;

print MyClass()            # 你可以通过这个类创建类实例，也就是对象
\输出：&amp;lt;__main__.Foo object at 0x1085ed950
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-python-元类-类-实例-属性之间的关系&#34;&gt;2. python 元类，类，实例，属性之间的关系&lt;/h3&gt;

&lt;h4 id=&#34;2-1-在python中-type为万物之源-type可以直接生成类-class-但也可以先生成元类-metaclass-再使用元类批量定制类-class&#34;&gt;2.1 在python中，type为万物之源，type可以直接生成类（class），但也可以先生成元类（metaclass），再使用元类批量定制类（class）&lt;/h4&gt;

&lt;p&gt;语法格式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyShinyClass(object):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以手动通过type创建，其实&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;MyShinyClass = type(&#39;MyShinyClass&#39;, (), {})  # 返回一个类对象
print MyShinyClass
\#输出：&amp;lt;class &#39;__main__.MyShinyClass&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print MyShinyClass()  #  创建一个该类的实例
#输出：&amp;lt;__main__.MyShinyClass object at 0x1085cd810&amp;gt;
你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。

1、构建Foo类
#构建目标代码
class Foo(object):
    bar = True
#使用type构建
Foo = type(&#39;Foo&#39;, (), {&#39;bar&#39;:True})

2.继承Foo类
#构建目标代码：
class FooChild(Foo):
    pass
#使用type构建
FooChild = type(&#39;FooChild&#39;, (Foo,),{})

print FooChild
#输出：&amp;lt;class &#39;__main__.FooChild&#39;&amp;gt;
print FooChild.bar   # bar属性是由Foo继承而来
#输出：True

3.为Foochild类增加方法
def echo_bar(self):
    print self.bar

FooChild = type(&#39;FooChild&#39;, (Foo,), {&#39;echo_bar&#39;: echo_bar})
hasattr(Foo, &#39;echo_bar&#39;)
#输出：False
hasattr(FooChild, &#39;echo_bar&#39;)
#输出：True
my_foo = FooChild()
my_foo.echo_bar()
#输出：True
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-什么是元类&#34;&gt;3. 什么是元类&lt;/h3&gt;

&lt;p&gt;通过上文的描述，我们知道了Python中的类也是对象。元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass = MetaClass()    #元类创建
MyObject = MyClass()     #类创建实例
实际上MyClass就是通过type()来创创建出MyClass类，它是type()类的一个实例；同时MyClass本身也是类，也可以创建出自己的实例，这里就是MyObject
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查&lt;strong&gt;class&lt;/strong&gt;属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
# 元类会自动将你通常传给‘type’的参数作为自己的参数传入
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    &#39;&#39;&#39;返回一个类对象，将属性都转为大写形式&#39;&#39;&#39;
    #选择所有不以&#39;__&#39;开头的属性
    attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith(&#39;__&#39;))
    # 将它们转为大写形式
    uppercase_attr = dict((name.upper(), value) for name, value in attrs)
    #通过&#39;type&#39;来做类对象的创建
    return type(future_class_name, future_class_parents, uppercase_attr)#返回一个类

# python2
class Foo(object):
    __metaclass__ = upper_attr
    bar = &#39;bip&#39;
# python 3    
class Foo(metaclass=Singleton):
    print(&amp;quot;A1&amp;quot;)
     #在代码执行到这里的时候，元类中的__new__方法和__init__方法其实已经被执行了，而不是在Foo实例化的时候执行。且仅会执行一次。
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
  </channel>
</rss>